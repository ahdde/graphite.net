//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Globalization;
using System.Linq;

namespace ahd.Graphite.Base
{
	public abstract partial class SeriesListBase
	{
		// skipped ConstantLine
		// skipped Events
		// skipped Identity
		// skipped RandomWalk
		// skipped RandomWalkFunction
		// skipped Reduce
		// skipped ReduceSeries
		// skipped SeriesByTag
		// skipped Sin
		// skipped SinFunction
		// skipped Threshold
		// skipped Time
		// skipped TimeFunction
		// skipped VerticalLine
		/// <summary>
		/// Takes one metric or a wildcard seriesList and applies the mathematical abs function to each
		/// datapoint transforming it to its absolute value.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=absolute(Server.instance01.threads.busy)
		///   &amp;target=absolute(Server.instance*.threads.busy)
		/// </code>
		/// </summary>
		public SeriesListFunction Absolute()
		{
			return Unary("absolute");
		}

		/// <summary>
		/// Aggregate series using the specified function.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=aggregate(host.cpu-[0-7].cpu-{user,system}.value, "sum")
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=sumSeries(host.cpu-[0-7].cpu-{user,system}.value)
		/// </code>
		/// <para>
		/// This function can be used with aggregation functions ``average``, ``median``, ``sum``, ``min``,
		/// ``max``, ``diff``, ``stddev``, ``count``, ``range``, ``multiply`` &amp; ``last``.
		/// </para>
		/// </summary>
		public SeriesListFunction Aggregate(string func, double? xFilesFactor = null)
		{
			return Ternary("aggregate", SingleQuote(func), xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Aggregate series using the specified function.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=aggregate(host.cpu-[0-7].cpu-{user,system}.value, "sum")
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=sumSeries(host.cpu-[0-7].cpu-{user,system}.value)
		/// </code>
		/// <para>
		/// This function can be used with aggregation functions ``average``, ``median``, ``sum``, ``min``,
		/// ``max``, ``diff``, ``stddev``, ``count``, ``range``, ``multiply`` &amp; ``last``.
		/// </para>
		/// </summary>
		public SeriesListFunction Aggregate(string func)
		{
			return Binary("aggregate", SingleQuote(func));
		}

		/// <summary>
		/// Takes a metric or wildcard seriesList and draws a horizontal line
		/// based on the function applied to each series.
		/// <para>
		/// If the optional keepStep parameter is set to True, the result will
		/// have the same time period and step as the source series.
		/// </para>
		/// <para>
		/// Note: By default, the graphite renderer consolidates data points by
		/// averaging data points over time. If you are using the 'min' or 'max'
		/// function for aggregateLine, this can cause an unusual gap in the
		/// line drawn by this function and the data itself. To fix this, you
		/// should use the consolidateBy() function with the same function
		/// argument you are using for aggregateLine. This will ensure that the
		/// proper data points are retained and the graph should line up
		/// correctly.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=aggregateLine(server01.connections.total, 'avg')
		///   &amp;target=aggregateLine(server*.connections.total, 'avg')
		/// </code>
		/// </summary>
		public SeriesListFunction AggregateLine(string func = "average", bool keepStep = false)
		{
			return Ternary("aggregateLine", SingleQuote(func), keepStep?1:0);
		}

		/// <summary>
		/// Takes a metric or wildcard seriesList and draws a horizontal line
		/// based on the function applied to each series.
		/// <para>
		/// If the optional keepStep parameter is set to True, the result will
		/// have the same time period and step as the source series.
		/// </para>
		/// <para>
		/// Note: By default, the graphite renderer consolidates data points by
		/// averaging data points over time. If you are using the 'min' or 'max'
		/// function for aggregateLine, this can cause an unusual gap in the
		/// line drawn by this function and the data itself. To fix this, you
		/// should use the consolidateBy() function with the same function
		/// argument you are using for aggregateLine. This will ensure that the
		/// proper data points are retained and the graph should line up
		/// correctly.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=aggregateLine(server01.connections.total, 'avg')
		///   &amp;target=aggregateLine(server*.connections.total, 'avg')
		/// </code>
		/// </summary>
		public SeriesListFunction AggregateLine(string func = "average")
		{
			return Binary("aggregateLine", SingleQuote(func));
		}

		/// <summary>
		/// Takes a metric or wildcard seriesList and draws a horizontal line
		/// based on the function applied to each series.
		/// <para>
		/// If the optional keepStep parameter is set to True, the result will
		/// have the same time period and step as the source series.
		/// </para>
		/// <para>
		/// Note: By default, the graphite renderer consolidates data points by
		/// averaging data points over time. If you are using the 'min' or 'max'
		/// function for aggregateLine, this can cause an unusual gap in the
		/// line drawn by this function and the data itself. To fix this, you
		/// should use the consolidateBy() function with the same function
		/// argument you are using for aggregateLine. This will ensure that the
		/// proper data points are retained and the graph should line up
		/// correctly.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=aggregateLine(server01.connections.total, 'avg')
		///   &amp;target=aggregateLine(server*.connections.total, 'avg')
		/// </code>
		/// </summary>
		public SeriesListFunction AggregateLine()
		{
			return Unary("aggregateLine");
		}

		/// <summary>
		/// Call aggregator after inserting wildcards at the given position(s).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=aggregateWithWildcards(host.cpu-[0-7].cpu-{user,system}.value, "sum", 1)
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=sumSeries(host.cpu-[0-7].cpu-user.value)&amp;target=sumSeries(host.cpu-[0-7].cpu-system.value)
		///   # or
		///   &amp;target=aggregate(host.cpu-[0-7].cpu-user.value,"sum")&amp;target=aggregate(host.cpu-[0-7].cpu-system.value,"sum")
		/// </code>
		/// <para>
		/// This function can be used with all aggregation functions supported by
		/// :py:func:`aggregate &lt;aggregate&gt;`: ``average``, ``median``, ``sum``, ``min``, ``max``, ``diff``,
		/// ``stddev``, ``range`` &amp; ``multiply``.
		/// </para>
		/// <para>
		/// This complements :py:func:`groupByNodes &lt;groupByNodes&gt;` which takes a list of nodes that must match in each group.
		/// </para>
		/// </summary>
		public SeriesListFunction AggregateWithWildcards(string func, params uint[] position)
		{
			return new SeriesListFunction("aggregateWithWildcards", Merge(this, Merge(SingleQuote(func), position)));
		}

		/// <summary>
		/// Call aggregator after inserting wildcards at the given position(s).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=aggregateWithWildcards(host.cpu-[0-7].cpu-{user,system}.value, "sum", 1)
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=sumSeries(host.cpu-[0-7].cpu-user.value)&amp;target=sumSeries(host.cpu-[0-7].cpu-system.value)
		///   # or
		///   &amp;target=aggregate(host.cpu-[0-7].cpu-user.value,"sum")&amp;target=aggregate(host.cpu-[0-7].cpu-system.value,"sum")
		/// </code>
		/// <para>
		/// This function can be used with all aggregation functions supported by
		/// :py:func:`aggregate &lt;aggregate&gt;`: ``average``, ``median``, ``sum``, ``min``, ``max``, ``diff``,
		/// ``stddev``, ``range`` &amp; ``multiply``.
		/// </para>
		/// <para>
		/// This complements :py:func:`groupByNodes &lt;groupByNodes&gt;` which takes a list of nodes that must match in each group.
		/// </para>
		/// </summary>
		public SeriesListFunction AggregateWithWildcards(string func)
		{
			return Binary("aggregateWithWildcards", SingleQuote(func));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList and a string in quotes.
		/// Prints the string instead of the metric name in the legend.
		/// <code>
		///   &amp;target=alias(Sales.widgets.largeBlue,"Large Blue Widgets")
		/// </code>
		/// </summary>
		public SeriesListFunction Alias(string newName)
		{
			return Binary("alias", SingleQuote(newName));
		}

		/// <summary>
		/// Takes a seriesList and applies an alias derived from the base metric name.
		/// <code>
		///   &amp;target=aliasByMetric(carbon.agents.graphite.creates)
		/// </code>
		/// </summary>
		public SeriesListFunction AliasByMetric()
		{
			return Unary("aliasByMetric");
		}

		/// <summary>
		/// Takes a seriesList and applies an alias derived from one or more "node"
		/// portion/s of the target name or tags. Node indices are 0 indexed.
		/// <code>
		///   &amp;target=aliasByNode(ganglia.*.cpu.load5,1)
		/// </code>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <code>
		///   &amp;target=seriesByTag("name=~cpu.load.*", "server=~server[1-9]+", "datacenter=dc1")|aliasByNode("datacenter", "server", 1)
		/// </code>
		/// <para>
		///   # will produce output series like
		///   # dc1.server1.load5, dc1.server2.load5, dc1.server1.load10, dc1.server2.load10
		/// </para>
		/// </summary>
		public SeriesListFunction AliasByNode(params uint[] nodes)
		{
			return new SeriesListFunction("aliasByNode", Merge(this, nodes));
		}

		/// <summary>
		/// Takes a seriesList and applies an alias derived from one or more "node"
		/// portion/s of the target name or tags. Node indices are 0 indexed.
		/// <code>
		///   &amp;target=aliasByNode(ganglia.*.cpu.load5,1)
		/// </code>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <code>
		///   &amp;target=seriesByTag("name=~cpu.load.*", "server=~server[1-9]+", "datacenter=dc1")|aliasByNode("datacenter", "server", 1)
		/// </code>
		/// <para>
		///   # will produce output series like
		///   # dc1.server1.load5, dc1.server2.load5, dc1.server1.load10, dc1.server2.load10
		/// </para>
		/// </summary>
		public SeriesListFunction AliasByNode(params string[] nodes)
		{
			return new SeriesListFunction("aliasByNode", Merge(this, nodes.Select(SingleQuote).ToArray()));
		}

		/// <summary>
		/// Takes a seriesList and applies an alias derived from one or more tags and/or nodes
		/// <code>
		///   &amp;target=seriesByTag("name=cpu")|aliasByTags("server","name")
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aliasByNode &lt;aliasByNode&gt;`.
		/// </para>
		/// </summary>
		public SeriesListFunction AliasByTags(params uint[] tags)
		{
			return new SeriesListFunction("aliasByTags", Merge(this, tags));
		}

		/// <summary>
		/// Takes a seriesList and applies an alias derived from one or more tags and/or nodes
		/// <code>
		///   &amp;target=seriesByTag("name=cpu")|aliasByTags("server","name")
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aliasByNode &lt;aliasByNode&gt;`.
		/// </para>
		/// </summary>
		public SeriesListFunction AliasByTags(params string[] tags)
		{
			return new SeriesListFunction("aliasByTags", Merge(this, tags.Select(SingleQuote).ToArray()));
		}

		/// <summary>
		/// Performs a query to alias the metrics in seriesList.
		/// <code>
		///   &amp;target=aliasQuery(channel.power.*,"channel\.power\.([0-9]+)","channel.frequency.\1", "Channel %d MHz")
		/// </code>
		/// <para>
		/// The series in seriesList will be aliased by first translating the series names using
		/// the search &amp; replace parameters, then using the last value of the resulting series
		/// to construct the alias using sprintf-style syntax.
		/// </para>
		/// </summary>
		public SeriesListFunction AliasQuery(string search, string replace, string newName)
		{
			return Quaternary("aliasQuery", SingleQuote(search), SingleQuote(replace), SingleQuote(newName));
		}

		/// <summary>
		/// Runs series names through a regex search/replace.
		/// <code>
		///   &amp;target=aliasSub(ip.*TCP*,"^.*TCP(\d+)","\1")
		/// </code>
		/// </summary>
		public SeriesListFunction AliasSub(string search, string replace)
		{
			return Ternary("aliasSub", SingleQuote(search), SingleQuote(replace));
		}

		/// <summary>
		/// Assigns the given alpha transparency setting to the series. Takes a float value between 0 and 1.
		/// </summary>
		public SeriesListFunction Alpha(double alpha)
		{
			return Binary("alpha", alpha.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Takes a seriesList and applies some complicated function (described by a string), replacing templates with unique
		/// prefixes of keys from the seriesList (the key is all nodes up to the index given as `nodeNum`).
		/// <para>
		/// If the `newName` parameter is provided, the name of the resulting series will be given by that parameter, with any
		/// "%" characters replaced by the unique prefix.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=applyByNode(servers.*.disk.bytes_free,1,"divideSeries(%.disk.bytes_free,sumSeries(%.disk.bytes_*))")
		/// </code>
		/// <para>
		/// Would find all series which match `servers.*.disk.bytes_free`, then trim them down to unique series up to the node
		/// given by nodeNum, then fill them into the template function provided (replacing % by the prefixes).
		/// </para>
		/// <para>
		/// Additional Examples:
		/// </para>
		/// <para>
		/// Given keys of
		/// </para>
		/// <para>
		/// - `stats.counts.haproxy.web.2XX`
		/// - `stats.counts.haproxy.web.3XX`
		/// - `stats.counts.haproxy.web.5XX`
		/// - `stats.counts.haproxy.microservice.2XX`
		/// - `stats.counts.haproxy.microservice.3XX`
		/// - `stats.counts.haproxy.microservice.5XX`
		/// </para>
		/// <para>
		/// The following will return the rate of 5XX's per service:
		/// </para>
		/// <code>
		///   applyByNode(stats.counts.haproxy.*.*XX, 3, "asPercent(%.5XX, sumSeries(%.*XX))", "%.pct_5XX")
		/// </code>
		/// <para>
		/// The output series would have keys `stats.counts.haproxy.web.pct_5XX` and `stats.counts.haproxy.microservice.pct_5XX`.
		/// </para>
		/// </summary>
		public SeriesListFunction ApplyByNode(uint nodeNum, string templateFunction, string newName = null)
		{
			return Quaternary("applyByNode", nodeNum, SingleQuote(templateFunction), SingleQuote(newName));
		}

		/// <summary>
		/// Takes a seriesList and applies some complicated function (described by a string), replacing templates with unique
		/// prefixes of keys from the seriesList (the key is all nodes up to the index given as `nodeNum`).
		/// <para>
		/// If the `newName` parameter is provided, the name of the resulting series will be given by that parameter, with any
		/// "%" characters replaced by the unique prefix.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=applyByNode(servers.*.disk.bytes_free,1,"divideSeries(%.disk.bytes_free,sumSeries(%.disk.bytes_*))")
		/// </code>
		/// <para>
		/// Would find all series which match `servers.*.disk.bytes_free`, then trim them down to unique series up to the node
		/// given by nodeNum, then fill them into the template function provided (replacing % by the prefixes).
		/// </para>
		/// <para>
		/// Additional Examples:
		/// </para>
		/// <para>
		/// Given keys of
		/// </para>
		/// <para>
		/// - `stats.counts.haproxy.web.2XX`
		/// - `stats.counts.haproxy.web.3XX`
		/// - `stats.counts.haproxy.web.5XX`
		/// - `stats.counts.haproxy.microservice.2XX`
		/// - `stats.counts.haproxy.microservice.3XX`
		/// - `stats.counts.haproxy.microservice.5XX`
		/// </para>
		/// <para>
		/// The following will return the rate of 5XX's per service:
		/// </para>
		/// <code>
		///   applyByNode(stats.counts.haproxy.*.*XX, 3, "asPercent(%.5XX, sumSeries(%.*XX))", "%.pct_5XX")
		/// </code>
		/// <para>
		/// The output series would have keys `stats.counts.haproxy.web.pct_5XX` and `stats.counts.haproxy.microservice.pct_5XX`.
		/// </para>
		/// </summary>
		public SeriesListFunction ApplyByNode(uint nodeNum, string templateFunction)
		{
			return Ternary("applyByNode", nodeNum, SingleQuote(templateFunction));
		}

		/// <summary>
		/// Draws the vertical area in between the two series in seriesList. Useful for
		/// visualizing a range such as the minimum and maximum latency for a service.
		/// <para>
		/// areaBetween expects **exactly one argument** that results in exactly two series
		/// (see example below). The order of the lower and higher values series does not
		/// matter. The visualization only works when used in conjunction with
		/// ``areaMode=stacked``.
		/// </para>
		/// <para>
		/// Most likely use case is to provide a band within which another metric should
		/// move. In such case applying an ``alpha()``, as in the second example, gives
		/// best visual results.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=areaBetween(service.latency.{min,max})&amp;areaMode=stacked
		/// </code>
		/// <para>
		///   &amp;target=alpha(areaBetween(service.latency.{min,max}),0.3)&amp;areaMode=stacked
		/// </para>
		/// <para>
		/// If for instance, you need to build a seriesList, you should use the ``group``
		/// function, like so:
		/// </para>
		/// <code>
		///   &amp;target=areaBetween(group(minSeries(a.*.min),maxSeries(a.*.max)))
		/// </code>
		/// </summary>
		public SeriesListFunction AreaBetween()
		{
			return Unary("areaBetween");
		}

		/// <summary>
		/// Calculates a percentage of the total of a wildcard series. If `total` is specified,
		/// each series will be calculated as a percentage of that total. If `total` is not specified,
		/// the sum of all points in the wildcard series will be used instead.
		/// <para>
		/// A list of nodes can optionally be provided, if so they will be used to match series with their
		/// corresponding totals following the same logic as :py:func:`groupByNodes &lt;groupByNodes&gt;`.
		/// </para>
		/// <para>
		/// When passing `nodes` the `total` parameter may be a series list or `None`.  If it is `None` then
		/// for each series in `seriesList` the percentage of the sum of series in that group will be returned.
		/// </para>
		/// <para>
		/// When not passing `nodes`, the `total` parameter may be a single series, reference the same number
		/// of series as `seriesList` or be a numeric value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   # Server01 connections failed and succeeded as a percentage of Server01 connections attempted
		///   &amp;target=asPercent(Server01.connections.{failed,succeeded}, Server01.connections.attempted)
		/// </code>
		/// <para>
		///   # For each server, its connections failed as a percentage of its connections attempted
		///   &amp;target=asPercent(Server*.connections.failed, Server*.connections.attempted)
		/// </para>
		/// <para>
		///   # For each server, its connections failed and succeeded as a percentage of its connections attemped
		///   &amp;target=asPercent(Server*.connections.{failed,succeeded}, Server*.connections.attempted, 0)
		/// </para>
		/// <para>
		///   # apache01.threads.busy as a percentage of 1500
		///   &amp;target=asPercent(apache01.threads.busy,1500)
		/// </para>
		/// <para>
		///   # Server01 cpu stats as a percentage of its total
		///   &amp;target=asPercent(Server01.cpu.*.jiffies)
		/// </para>
		/// <para>
		///   # cpu stats for each server as a percentage of its total
		///   &amp;target=asPercent(Server*.cpu.*.jiffies, None, 0)
		/// </para>
		/// <para>
		/// When using `nodes`, any series or totals that can't be matched will create output series with
		/// names like ``asPercent(someSeries,MISSING)`` or ``asPercent(MISSING,someTotalSeries)`` and all
		/// values set to None. If desired these series can be filtered out by piping the result through
		/// ``|exclude("MISSING")`` as shown below:
		/// </para>
		/// <code>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)
		/// </code>
		/// <para>
		///   # will produce 3 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		///   # asPercent(Server2.memory.used,MISSING) [all values will be None]
		///   # asPercent(MISSING,Server3.memory.total) [all values will be None]
		/// </para>
		/// <para>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)|exclude("MISSING")
		/// </para>
		/// <para>
		///   # will produce 1 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   When `total` is a seriesList, specifying `nodes` to match series with the corresponding total
		///   series will increase reliability.
		/// </para>
		/// </summary>
		public SeriesListFunction AsPercent(SeriesListBase total = null, params uint[] nodes)
		{
			return new SeriesListFunction("asPercent", Merge(this, Merge(total, nodes)));
		}

		/// <summary>
		/// Calculates a percentage of the total of a wildcard series. If `total` is specified,
		/// each series will be calculated as a percentage of that total. If `total` is not specified,
		/// the sum of all points in the wildcard series will be used instead.
		/// <para>
		/// A list of nodes can optionally be provided, if so they will be used to match series with their
		/// corresponding totals following the same logic as :py:func:`groupByNodes &lt;groupByNodes&gt;`.
		/// </para>
		/// <para>
		/// When passing `nodes` the `total` parameter may be a series list or `None`.  If it is `None` then
		/// for each series in `seriesList` the percentage of the sum of series in that group will be returned.
		/// </para>
		/// <para>
		/// When not passing `nodes`, the `total` parameter may be a single series, reference the same number
		/// of series as `seriesList` or be a numeric value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   # Server01 connections failed and succeeded as a percentage of Server01 connections attempted
		///   &amp;target=asPercent(Server01.connections.{failed,succeeded}, Server01.connections.attempted)
		/// </code>
		/// <para>
		///   # For each server, its connections failed as a percentage of its connections attempted
		///   &amp;target=asPercent(Server*.connections.failed, Server*.connections.attempted)
		/// </para>
		/// <para>
		///   # For each server, its connections failed and succeeded as a percentage of its connections attemped
		///   &amp;target=asPercent(Server*.connections.{failed,succeeded}, Server*.connections.attempted, 0)
		/// </para>
		/// <para>
		///   # apache01.threads.busy as a percentage of 1500
		///   &amp;target=asPercent(apache01.threads.busy,1500)
		/// </para>
		/// <para>
		///   # Server01 cpu stats as a percentage of its total
		///   &amp;target=asPercent(Server01.cpu.*.jiffies)
		/// </para>
		/// <para>
		///   # cpu stats for each server as a percentage of its total
		///   &amp;target=asPercent(Server*.cpu.*.jiffies, None, 0)
		/// </para>
		/// <para>
		/// When using `nodes`, any series or totals that can't be matched will create output series with
		/// names like ``asPercent(someSeries,MISSING)`` or ``asPercent(MISSING,someTotalSeries)`` and all
		/// values set to None. If desired these series can be filtered out by piping the result through
		/// ``|exclude("MISSING")`` as shown below:
		/// </para>
		/// <code>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)
		/// </code>
		/// <para>
		///   # will produce 3 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		///   # asPercent(Server2.memory.used,MISSING) [all values will be None]
		///   # asPercent(MISSING,Server3.memory.total) [all values will be None]
		/// </para>
		/// <para>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)|exclude("MISSING")
		/// </para>
		/// <para>
		///   # will produce 1 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   When `total` is a seriesList, specifying `nodes` to match series with the corresponding total
		///   series will increase reliability.
		/// </para>
		/// </summary>
		public SeriesListFunction AsPercent(SeriesListBase total = null, params string[] nodes)
		{
			return new SeriesListFunction("asPercent", Merge(this, Merge(total, nodes.Select(SingleQuote).ToArray())));
		}

		/// <summary>
		/// Calculates a percentage of the total of a wildcard series. If `total` is specified,
		/// each series will be calculated as a percentage of that total. If `total` is not specified,
		/// the sum of all points in the wildcard series will be used instead.
		/// <para>
		/// A list of nodes can optionally be provided, if so they will be used to match series with their
		/// corresponding totals following the same logic as :py:func:`groupByNodes &lt;groupByNodes&gt;`.
		/// </para>
		/// <para>
		/// When passing `nodes` the `total` parameter may be a series list or `None`.  If it is `None` then
		/// for each series in `seriesList` the percentage of the sum of series in that group will be returned.
		/// </para>
		/// <para>
		/// When not passing `nodes`, the `total` parameter may be a single series, reference the same number
		/// of series as `seriesList` or be a numeric value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   # Server01 connections failed and succeeded as a percentage of Server01 connections attempted
		///   &amp;target=asPercent(Server01.connections.{failed,succeeded}, Server01.connections.attempted)
		/// </code>
		/// <para>
		///   # For each server, its connections failed as a percentage of its connections attempted
		///   &amp;target=asPercent(Server*.connections.failed, Server*.connections.attempted)
		/// </para>
		/// <para>
		///   # For each server, its connections failed and succeeded as a percentage of its connections attemped
		///   &amp;target=asPercent(Server*.connections.{failed,succeeded}, Server*.connections.attempted, 0)
		/// </para>
		/// <para>
		///   # apache01.threads.busy as a percentage of 1500
		///   &amp;target=asPercent(apache01.threads.busy,1500)
		/// </para>
		/// <para>
		///   # Server01 cpu stats as a percentage of its total
		///   &amp;target=asPercent(Server01.cpu.*.jiffies)
		/// </para>
		/// <para>
		///   # cpu stats for each server as a percentage of its total
		///   &amp;target=asPercent(Server*.cpu.*.jiffies, None, 0)
		/// </para>
		/// <para>
		/// When using `nodes`, any series or totals that can't be matched will create output series with
		/// names like ``asPercent(someSeries,MISSING)`` or ``asPercent(MISSING,someTotalSeries)`` and all
		/// values set to None. If desired these series can be filtered out by piping the result through
		/// ``|exclude("MISSING")`` as shown below:
		/// </para>
		/// <code>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)
		/// </code>
		/// <para>
		///   # will produce 3 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		///   # asPercent(Server2.memory.used,MISSING) [all values will be None]
		///   # asPercent(MISSING,Server3.memory.total) [all values will be None]
		/// </para>
		/// <para>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)|exclude("MISSING")
		/// </para>
		/// <para>
		///   # will produce 1 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   When `total` is a seriesList, specifying `nodes` to match series with the corresponding total
		///   series will increase reliability.
		/// </para>
		/// </summary>
		public SeriesListFunction AsPercent(SeriesListBase total = null)
		{
			return Binary("asPercent", total);
		}

		/// <summary>
		/// Calculates a percentage of the total of a wildcard series. If `total` is specified,
		/// each series will be calculated as a percentage of that total. If `total` is not specified,
		/// the sum of all points in the wildcard series will be used instead.
		/// <para>
		/// A list of nodes can optionally be provided, if so they will be used to match series with their
		/// corresponding totals following the same logic as :py:func:`groupByNodes &lt;groupByNodes&gt;`.
		/// </para>
		/// <para>
		/// When passing `nodes` the `total` parameter may be a series list or `None`.  If it is `None` then
		/// for each series in `seriesList` the percentage of the sum of series in that group will be returned.
		/// </para>
		/// <para>
		/// When not passing `nodes`, the `total` parameter may be a single series, reference the same number
		/// of series as `seriesList` or be a numeric value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   # Server01 connections failed and succeeded as a percentage of Server01 connections attempted
		///   &amp;target=asPercent(Server01.connections.{failed,succeeded}, Server01.connections.attempted)
		/// </code>
		/// <para>
		///   # For each server, its connections failed as a percentage of its connections attempted
		///   &amp;target=asPercent(Server*.connections.failed, Server*.connections.attempted)
		/// </para>
		/// <para>
		///   # For each server, its connections failed and succeeded as a percentage of its connections attemped
		///   &amp;target=asPercent(Server*.connections.{failed,succeeded}, Server*.connections.attempted, 0)
		/// </para>
		/// <para>
		///   # apache01.threads.busy as a percentage of 1500
		///   &amp;target=asPercent(apache01.threads.busy,1500)
		/// </para>
		/// <para>
		///   # Server01 cpu stats as a percentage of its total
		///   &amp;target=asPercent(Server01.cpu.*.jiffies)
		/// </para>
		/// <para>
		///   # cpu stats for each server as a percentage of its total
		///   &amp;target=asPercent(Server*.cpu.*.jiffies, None, 0)
		/// </para>
		/// <para>
		/// When using `nodes`, any series or totals that can't be matched will create output series with
		/// names like ``asPercent(someSeries,MISSING)`` or ``asPercent(MISSING,someTotalSeries)`` and all
		/// values set to None. If desired these series can be filtered out by piping the result through
		/// ``|exclude("MISSING")`` as shown below:
		/// </para>
		/// <code>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)
		/// </code>
		/// <para>
		///   # will produce 3 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		///   # asPercent(Server2.memory.used,MISSING) [all values will be None]
		///   # asPercent(MISSING,Server3.memory.total) [all values will be None]
		/// </para>
		/// <para>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)|exclude("MISSING")
		/// </para>
		/// <para>
		///   # will produce 1 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   When `total` is a seriesList, specifying `nodes` to match series with the corresponding total
		///   series will increase reliability.
		/// </para>
		/// </summary>
		public SeriesListFunction AsPercent()
		{
			return Unary("asPercent");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Out of all metrics passed, draws only the metrics with an average value
		/// above N for the time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=averageAbove(server*.instance*.threads.busy,25)
		/// </code>
		/// <para>
		/// Draws the servers with average values above 25.
		/// </para>
		/// </summary>
		public SeriesListFunction AverageAbove(int n)
		{
			return Binary("averageAbove", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Out of all metrics passed, draws only the metrics with an average value
		/// below N for the time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=averageBelow(server*.instance*.threads.busy,25)
		/// </code>
		/// <para>
		/// Draws the servers with average values below 25.
		/// </para>
		/// </summary>
		public SeriesListFunction AverageBelow(int n)
		{
			return Binary("averageBelow", n);
		}

		/// <summary>
		/// Removes series lying inside an average percentile interval
		/// </summary>
		public SeriesListFunction AverageOutsidePercentile(int n)
		{
			return Binary("averageOutsidePercentile", n);
		}

		/// <summary>
		/// Short Alias: avg()
		/// <para>
		/// Takes one metric or a wildcard seriesList.
		/// Draws the average value of all metrics passed at each time.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=averageSeries(company.server.*.threads.busy)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``average``.
		/// </para>
		/// </summary>
		public SeriesListFunction AverageSeries(params SeriesListBase[] seriesLists)
		{
			return Multiple("averageSeries", seriesLists);
		}

		/// <summary>
		/// Call averageSeries after inserting wildcards at the given position(s).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=averageSeriesWithWildcards(host.cpu-[0-7].cpu-{user,system}.value, 1)
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=averageSeries(host.*.cpu-user.value)&amp;target=averageSeries(host.*.cpu-system.value)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregateWithWildcards &lt;aggregateWithWildcards&gt;` with aggregation ``average``.
		/// </para>
		/// </summary>
		public SeriesListFunction AverageSeriesWithWildcards(params uint[] position)
		{
			return new SeriesListFunction("averageSeriesWithWildcards", Merge(this, position));
		}

		/// <summary>
		/// Call averageSeries after inserting wildcards at the given position(s).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=averageSeriesWithWildcards(host.cpu-[0-7].cpu-{user,system}.value, 1)
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=averageSeries(host.*.cpu-user.value)&amp;target=averageSeries(host.*.cpu-system.value)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregateWithWildcards &lt;aggregateWithWildcards&gt;` with aggregation ``average``.
		/// </para>
		/// </summary>
		public SeriesListFunction AverageSeriesWithWildcards()
		{
			return Unary("averageSeriesWithWildcards");
		}

		/// <summary>
		/// Short Alias: avg()
		/// <para>
		/// Takes one metric or a wildcard seriesList.
		/// Draws the average value of all metrics passed at each time.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=averageSeries(company.server.*.threads.busy)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``average``.
		/// </para>
		/// </summary>
		public SeriesListFunction Avg(params SeriesListBase[] seriesLists)
		{
			return Multiple("avg", seriesLists);
		}

		/// <summary>
		/// Takes a series list and modifies the aliases to provide column aligned
		/// output with Current, Max, and Min values in the style of cacti. Optionally
		/// takes a "system" value to apply unit formatting in the same style as the
		/// Y-axis, or a "unit" string to append an arbitrary unit suffix.
		/// <code>
		///   &amp;target=cactiStyle(ganglia.*.net.bytes_out,"si")
		///   &amp;target=cactiStyle(ganglia.*.net.bytes_out,"si","b")
		/// </code>
		/// <para>
		/// A possible value for ``system`` is ``si``, which would express your values in
		/// multiples of a thousand. A second option is to use ``binary`` which will
		/// instead express your values in multiples of 1024 (useful for network devices).
		/// </para>
		/// <para>
		/// Column alignment of the Current, Max, Min values works under two conditions:
		/// you use a monospace font such as terminus and use a single cactiStyle call, as
		/// separate cactiStyle calls are not aware of each other. In case you have
		/// different targets for which you would like to have cactiStyle to line up, you
		/// can use ``group()`` to combine them before applying cactiStyle, such as:
		/// </para>
		/// <code>
		///   &amp;target=cactiStyle(group(metricA,metricB))
		/// </code>
		/// </summary>
		public SeriesListFunction CactiStyle(string system = null, string units = null)
		{
			return Ternary("cactiStyle", SingleQuote(system), SingleQuote(units));
		}

		/// <summary>
		/// Takes a series list and modifies the aliases to provide column aligned
		/// output with Current, Max, and Min values in the style of cacti. Optionally
		/// takes a "system" value to apply unit formatting in the same style as the
		/// Y-axis, or a "unit" string to append an arbitrary unit suffix.
		/// <code>
		///   &amp;target=cactiStyle(ganglia.*.net.bytes_out,"si")
		///   &amp;target=cactiStyle(ganglia.*.net.bytes_out,"si","b")
		/// </code>
		/// <para>
		/// A possible value for ``system`` is ``si``, which would express your values in
		/// multiples of a thousand. A second option is to use ``binary`` which will
		/// instead express your values in multiples of 1024 (useful for network devices).
		/// </para>
		/// <para>
		/// Column alignment of the Current, Max, Min values works under two conditions:
		/// you use a monospace font such as terminus and use a single cactiStyle call, as
		/// separate cactiStyle calls are not aware of each other. In case you have
		/// different targets for which you would like to have cactiStyle to line up, you
		/// can use ``group()`` to combine them before applying cactiStyle, such as:
		/// </para>
		/// <code>
		///   &amp;target=cactiStyle(group(metricA,metricB))
		/// </code>
		/// </summary>
		public SeriesListFunction CactiStyle(string system = null)
		{
			return Binary("cactiStyle", SingleQuote(system));
		}

		/// <summary>
		/// Takes a series list and modifies the aliases to provide column aligned
		/// output with Current, Max, and Min values in the style of cacti. Optionally
		/// takes a "system" value to apply unit formatting in the same style as the
		/// Y-axis, or a "unit" string to append an arbitrary unit suffix.
		/// <code>
		///   &amp;target=cactiStyle(ganglia.*.net.bytes_out,"si")
		///   &amp;target=cactiStyle(ganglia.*.net.bytes_out,"si","b")
		/// </code>
		/// <para>
		/// A possible value for ``system`` is ``si``, which would express your values in
		/// multiples of a thousand. A second option is to use ``binary`` which will
		/// instead express your values in multiples of 1024 (useful for network devices).
		/// </para>
		/// <para>
		/// Column alignment of the Current, Max, Min values works under two conditions:
		/// you use a monospace font such as terminus and use a single cactiStyle call, as
		/// separate cactiStyle calls are not aware of each other. In case you have
		/// different targets for which you would like to have cactiStyle to line up, you
		/// can use ``group()`` to combine them before applying cactiStyle, such as:
		/// </para>
		/// <code>
		///   &amp;target=cactiStyle(group(metricA,metricB))
		/// </code>
		/// </summary>
		public SeriesListFunction CactiStyle()
		{
			return Unary("cactiStyle");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// Output 1 when the value changed, 0 when null or the same
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=changed(Server01.connections.handled)
		/// </code>
		/// </summary>
		public SeriesListFunction Changed()
		{
			return Unary("changed");
		}

		/// <summary>
		/// Assigns the given color to the seriesList
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=color(collectd.hostname.cpu.0.user, 'green')
		///   &amp;target=color(collectd.hostname.cpu.0.system, 'ff0000')
		///   &amp;target=color(collectd.hostname.cpu.0.idle, 'gray')
		///   &amp;target=color(collectd.hostname.cpu.0.idle, '6464ffaa')
		/// </code>
		/// </summary>
		public SeriesListFunction Color(string theColor)
		{
			return Binary("color", SingleQuote(theColor));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList and a consolidation function name.
		/// <para>
		/// Valid function names are 'sum', 'average', 'min', 'max', 'first' &amp; 'last'.
		/// </para>
		/// <para>
		/// When a graph is drawn where width of the graph size in pixels is smaller than
		/// the number of datapoints to be graphed, Graphite consolidates the values to
		/// to prevent line overlap. The consolidateBy() function changes the consolidation
		/// function from the default of 'average' to one of 'sum', 'max', 'min', 'first', or 'last'.
		/// This is especially useful in sales graphs, where fractional values make no sense and a 'sum'
		/// of consolidated values is appropriate.
		/// </para>
		/// <code>
		///   &amp;target=consolidateBy(Sales.widgets.largeBlue, 'sum')
		///   &amp;target=consolidateBy(Servers.web01.sda1.free_space, 'max')
		/// </code>
		/// </summary>
		public SeriesListFunction ConsolidateBy(string consolidationFunc)
		{
			return Binary("consolidateBy", SingleQuote(consolidationFunc));
		}

		/// <summary>
		/// Draws a horizontal line representing the number of nodes found in the seriesList.
		/// <code>
		///   &amp;target=countSeries(carbon.agents.*.*)
		/// </code>
		/// </summary>
		public SeriesListFunction CountSeries(params SeriesListBase[] seriesLists)
		{
			return Multiple("countSeries", seriesLists);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// <para>
		/// When a graph is drawn where width of the graph size in pixels is smaller than
		/// the number of datapoints to be graphed, Graphite consolidates the values to
		/// to prevent line overlap. The cumulative() function changes the consolidation
		/// function from the default of 'average' to 'sum'. This is especially useful in
		/// sales graphs, where fractional values make no sense and a 'sum' of consolidated
		/// values is appropriate.
		/// </para>
		/// <para>
		/// Alias for :func:`consolidateBy(series, 'sum') &lt;graphite.render.functions.consolidateBy&gt;`
		/// </para>
		/// <code>
		///   &amp;target=cumulative(Sales.widgets.largeBlue)
		/// </code>
		/// </summary>
		public SeriesListFunction Cumulative()
		{
			return Unary("cumulative");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Out of all metrics passed, draws only the  metrics whose value is above N
		/// at the end of the time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=currentAbove(server*.instance*.threads.busy,50)
		/// </code>
		/// <para>
		/// Draws the servers with more than 50 busy threads.
		/// </para>
		/// </summary>
		public SeriesListFunction CurrentAbove(int n)
		{
			return Binary("currentAbove", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Out of all metrics passed, draws only the  metrics whose value is below N
		/// at the end of the time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=currentBelow(server*.instance*.threads.busy,3)
		/// </code>
		/// <para>
		/// Draws the servers with less than 3 busy threads.
		/// </para>
		/// </summary>
		public SeriesListFunction CurrentBelow(int n)
		{
			return Binary("currentBelow", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a float F.
		/// <para>
		/// Draw the selected metrics with a dotted line with segments of length F
		/// If omitted, the default length of the segments is 5.0
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=dashed(server01.instance01.memory.free,2.5)
		/// </code>
		/// </summary>
		public SeriesListFunction Dashed(int dashLength = 5)
		{
			return Binary("dashed", dashLength);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a float F.
		/// <para>
		/// Draw the selected metrics with a dotted line with segments of length F
		/// If omitted, the default length of the segments is 5.0
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=dashed(server01.instance01.memory.free,2.5)
		/// </code>
		/// </summary>
		public SeriesListFunction Dashed()
		{
			return Unary("dashed");
		}

		/// <summary>
		/// This shifts all samples later by an integer number of steps. This can be
		/// used for custom derivative calculations, among other things. Note: this
		/// will pad the early end of the data with None for every step shifted.
		/// <para>
		/// This complements other time-displacement functions such as timeShift and
		/// timeSlice, in that this function is indifferent about the step intervals
		/// being shifted.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=divideSeries(server.FreeSpace,delay(server.FreeSpace,1))
		/// </code>
		/// <para>
		/// This computes the change in server free space as a percentage of the previous
		/// free space.
		/// </para>
		/// </summary>
		public SeriesListFunction Delay(int steps)
		{
			return Binary("delay", steps);
		}

		/// <summary>
		/// This is the opposite of the integral function.  This is useful for taking a
		/// running total metric and calculating the delta between subsequent data points.
		/// <para>
		/// This function does not normalize for periods of time, as a true derivative would.
		/// Instead see the perSecond() function to calculate a rate of change over time.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=derivative(company.server.application01.ifconfig.TXPackets)
		/// </code>
		/// <para>
		/// Each time you run ifconfig, the RX and TXPackets are higher (assuming there
		/// is network traffic.) By applying the derivative function, you can get an
		/// idea of the packets per minute sent or received, even though you're only
		/// recording the total.
		/// </para>
		/// </summary>
		public SeriesListFunction Derivative()
		{
			return Unary("derivative");
		}

		/// <summary>
		/// Subtracts series 2 through n from series 1.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=diffSeries(service.connections.total,service.connections.failed)
		/// </code>
		/// <para>
		/// To diff a series and a constant, one should use offset instead of (or in
		/// addition to) diffSeries
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=offset(service.connections.total,-5)
		/// </code>
		/// <para>
		///   &amp;target=offset(diffSeries(service.connections.total,service.connections.failed),-4)
		/// </para>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``diff``.
		/// </para>
		/// </summary>
		public SeriesListFunction DiffSeries(params SeriesListBase[] seriesLists)
		{
			return Multiple("diffSeries", seriesLists);
		}

		/// <summary>
		/// Takes a dividend metric and a divisor metric and draws the division result.
		/// A constant may *not* be passed. To divide by a constant, use the scale()
		/// function (which is essentially a multiplication operation) and use the inverse
		/// of the dividend. (Division by 8 = multiplication by 1/8 or 0.125)
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=divideSeries(Series.dividends,Series.divisors)
		/// </code>
		/// </summary>
		public SeriesListFunction DivideSeries(SeriesListBase divisorSeries)
		{
			return Binary("divideSeries", divisorSeries);
		}

		/// <summary>
		/// Iterates over a two lists and divides list1[0] by list2[0], list1[1] by list2[1] and so on.
		/// The lists need to be the same length
		/// </summary>
		public SeriesListFunction DivideSeriesLists(SeriesListBase divisorSeriesList)
		{
			return Binary("divideSeriesLists", divisorSeriesList);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// If the value is zero, draw the line at 0.  If the value is above zero, draw
		/// the line at infinity. If the value is null or less than zero, do not draw
		/// the line.
		/// <para>
		/// Useful for displaying on/off metrics, such as exit codes. (0 = success,
		/// anything else = failure.)
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   drawAsInfinite(Testing.script.exitCode)
		/// </code>
		/// </summary>
		public SeriesListFunction DrawAsInfinite()
		{
			return Unary("drawAsInfinite");
		}

		/// <summary>
		/// Takes a metric or a wildcard seriesList, followed by a regular expression
		/// in double quotes.  Excludes metrics that match the regular expression.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=exclude(servers*.instance*.threads.busy,"server02")
		/// </code>
		/// </summary>
		public SeriesListFunction Exclude(string pattern)
		{
			return Binary("exclude", SingleQuote(pattern));
		}

		/// <summary>
		/// Takes a series of values and a window size and produces an exponential moving
		/// average utilizing the following formula:
		/// <code>
		///   ema(current) = constant * (Current Value) + (1 - constant) * ema(previous)
		/// </code>
		/// <para>
		/// The Constant is calculated as:
		/// </para>
		/// <code>
		///   constant = 2 / (windowSize + 1)
		/// </code>
		/// <para>
		/// The first period EMA uses a simple moving average for its value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=exponentialMovingAverage(*.transactions.count, 10)
		///   &amp;target=exponentialMovingAverage(*.transactions.count, '-10s')
		/// </code>
		/// </summary>
		public SeriesListFunction ExponentialMovingAverage(int windowSize)
		{
			return Binary("exponentialMovingAverage", windowSize);
		}

		/// <summary>
		/// Takes a series of values and a window size and produces an exponential moving
		/// average utilizing the following formula:
		/// <code>
		///   ema(current) = constant * (Current Value) + (1 - constant) * ema(previous)
		/// </code>
		/// <para>
		/// The Constant is calculated as:
		/// </para>
		/// <code>
		///   constant = 2 / (windowSize + 1)
		/// </code>
		/// <para>
		/// The first period EMA uses a simple moving average for its value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=exponentialMovingAverage(*.transactions.count, 10)
		///   &amp;target=exponentialMovingAverage(*.transactions.count, '-10s')
		/// </code>
		/// </summary>
		public SeriesListFunction ExponentialMovingAverage(string windowSize)
		{
			return Binary("exponentialMovingAverage", SingleQuote(windowSize));
		}

		/// <summary>
		/// Takes a wildcard seriesList, and a second fallback metric.
		/// If the wildcard does not match any series, draws the fallback metric.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=fallbackSeries(server*.requests_per_second, constantLine(0))
		/// </code>
		/// <para>
		/// Draws a 0 line when server metric does not exist.
		/// </para>
		/// </summary>
		public SeriesListFunction FallbackSeries(SeriesListBase fallback)
		{
			return Binary("fallbackSeries", fallback);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by a consolidation function, an operator and a threshold.
		/// Draws only the metrics which match the filter expression.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=filterSeries(system.interface.eth*.packetsSent, 'max', '&gt;', 1000)
		/// </code>
		/// <para>
		/// This would only display interfaces which has a peak throughput higher than 1000 packets/min.
		/// </para>
		/// <para>
		/// Supported aggregation functions: ``average``, ``median``, ``sum``, ``min``,
		/// ``max``, ``diff``, ``stddev``, ``range``, ``multiply`` &amp; ``last``.
		/// </para>
		/// <para>
		/// Supported operators: ``=``, ``!=``, ``&gt;``, ``&gt;=``, ``&lt;`` &amp; ``&lt;=``.
		/// </para>
		/// </summary>
		public SeriesListFunction FilterSeries(string func, string @operator, double threshold)
		{
			return Quaternary("filterSeries", SingleQuote(func), SingleQuote(@operator), threshold.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Takes a metric or a wildcard seriesList, followed by a regular expression
		/// in double quotes.  Excludes metrics that don't match the regular expression.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=grep(servers*.instance*.threads.busy,"server02")
		/// </code>
		/// </summary>
		public SeriesListFunction Grep(string pattern)
		{
			return Binary("grep", SingleQuote(pattern));
		}

		/// <summary>
		/// Takes an arbitrary number of seriesLists and adds them to a single seriesList. This is used
		/// to pass multiple seriesLists to a function which only takes one
		/// </summary>
		public SeriesListFunction Group(params SeriesListBase[] seriesLists)
		{
			return Multiple("group", seriesLists);
		}

		/// <summary>
		/// Takes a serieslist and maps a callback to subgroups within as defined by a common node
		/// <code>
		///   &amp;target=groupByNode(ganglia.by-function.*.*.cpu.load5,2,"sumSeries")
		/// </code>
		/// <para>
		/// Would return multiple series which are each the result of applying the "sumSeries" function
		/// to groups joined on the second node (0 indexed) resulting in a list of targets like
		/// </para>
		/// <code>
		///   sumSeries(ganglia.by-function.server1.*.cpu.load5),sumSeries(ganglia.by-function.server2.*.cpu.load5),...
		/// </code>
		/// <para>
		/// Node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// This is an alias for using :py:func:`groupByNodes &lt;groupByNodes&gt;` with a single node.
		/// </para>
		/// </summary>
		public SeriesListFunction GroupByNode(uint nodeNum, string callback = "average")
		{
			return Ternary("groupByNode", nodeNum, SingleQuote(callback));
		}

		/// <summary>
		/// Takes a serieslist and maps a callback to subgroups within as defined by a common node
		/// <code>
		///   &amp;target=groupByNode(ganglia.by-function.*.*.cpu.load5,2,"sumSeries")
		/// </code>
		/// <para>
		/// Would return multiple series which are each the result of applying the "sumSeries" function
		/// to groups joined on the second node (0 indexed) resulting in a list of targets like
		/// </para>
		/// <code>
		///   sumSeries(ganglia.by-function.server1.*.cpu.load5),sumSeries(ganglia.by-function.server2.*.cpu.load5),...
		/// </code>
		/// <para>
		/// Node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// This is an alias for using :py:func:`groupByNodes &lt;groupByNodes&gt;` with a single node.
		/// </para>
		/// </summary>
		public SeriesListFunction GroupByNode(string nodeNum, string callback = "average")
		{
			return Ternary("groupByNode", SingleQuote(nodeNum), SingleQuote(callback));
		}

		/// <summary>
		/// Takes a serieslist and maps a callback to subgroups within as defined by multiple nodes
		/// <code>
		///   &amp;target=groupByNodes(ganglia.server*.*.cpu.load*,"sum",1,4)
		/// </code>
		/// <para>
		/// Would return multiple series which are each the result of applying the "sum" aggregation
		/// to groups joined on the nodes' list (0 indexed) resulting in a list of targets like
		/// </para>
		/// <code>
		///   sumSeries(ganglia.server1.*.cpu.load5),sumSeries(ganglia.server1.*.cpu.load10),sumSeries(ganglia.server1.*.cpu.load15),sumSeries(ganglia.server2.*.cpu.load5),sumSeries(ganglia.server2.*.cpu.load10),sumSeries(ganglia.server2.*.cpu.load15),...
		/// </code>
		/// <para>
		/// This function can be used with all aggregation functions supported by
		/// :py:func:`aggregate &lt;aggregate&gt;`: ``average``, ``median``, ``sum``, ``min``, ``max``, ``diff``,
		/// ``stddev``, ``range`` &amp; ``multiply``.
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <code>
		///   &amp;target=seriesByTag("name=~cpu.load.*", "server=~server[1-9]+", "datacenter=~dc[1-9]+")|groupByNodes("average", "datacenter", 1)
		/// </code>
		/// <para>
		///   # will produce output series like
		///   # dc1.load5, dc2.load5, dc1.load10, dc2.load10
		/// </para>
		/// <para>
		/// This complements :py:func:`aggregateWithWildcards &lt;aggregateWithWildcards&gt;` which takes a list of wildcard nodes.
		/// </para>
		/// </summary>
		public SeriesListFunction GroupByNodes(string callback, params uint[] nodes)
		{
			return new SeriesListFunction("groupByNodes", Merge(this, Merge(SingleQuote(callback), nodes)));
		}

		/// <summary>
		/// Takes a serieslist and maps a callback to subgroups within as defined by multiple nodes
		/// <code>
		///   &amp;target=groupByNodes(ganglia.server*.*.cpu.load*,"sum",1,4)
		/// </code>
		/// <para>
		/// Would return multiple series which are each the result of applying the "sum" aggregation
		/// to groups joined on the nodes' list (0 indexed) resulting in a list of targets like
		/// </para>
		/// <code>
		///   sumSeries(ganglia.server1.*.cpu.load5),sumSeries(ganglia.server1.*.cpu.load10),sumSeries(ganglia.server1.*.cpu.load15),sumSeries(ganglia.server2.*.cpu.load5),sumSeries(ganglia.server2.*.cpu.load10),sumSeries(ganglia.server2.*.cpu.load15),...
		/// </code>
		/// <para>
		/// This function can be used with all aggregation functions supported by
		/// :py:func:`aggregate &lt;aggregate&gt;`: ``average``, ``median``, ``sum``, ``min``, ``max``, ``diff``,
		/// ``stddev``, ``range`` &amp; ``multiply``.
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <code>
		///   &amp;target=seriesByTag("name=~cpu.load.*", "server=~server[1-9]+", "datacenter=~dc[1-9]+")|groupByNodes("average", "datacenter", 1)
		/// </code>
		/// <para>
		///   # will produce output series like
		///   # dc1.load5, dc2.load5, dc1.load10, dc2.load10
		/// </para>
		/// <para>
		/// This complements :py:func:`aggregateWithWildcards &lt;aggregateWithWildcards&gt;` which takes a list of wildcard nodes.
		/// </para>
		/// </summary>
		public SeriesListFunction GroupByNodes(string callback, params string[] nodes)
		{
			return new SeriesListFunction("groupByNodes", Merge(this, Merge(SingleQuote(callback), nodes.Select(SingleQuote).ToArray())));
		}

		/// <summary>
		/// Takes a serieslist and maps a callback to subgroups within as defined by multiple tags
		/// <code>
		///   &amp;target=seriesByTag("name=cpu")|groupByTags("average","dc")
		/// </code>
		/// <para>
		/// Would return multiple series which are each the result of applying the "averageSeries" function
		/// to groups joined on the specified tags resulting in a list of targets like
		/// </para>
		/// <code>
		///   averageSeries(seriesByTag("name=cpu","dc=dc1")),averageSeries(seriesByTag("name=cpu","dc=dc2")),...
		/// </code>
		/// <para>
		/// This function can be used with all aggregation functions supported by
		/// :py:func:`aggregate &lt;aggregate&gt;`: ``average``, ``median``, ``sum``, ``min``, ``max``, ``diff``,
		/// ``stddev``, ``range`` &amp; ``multiply``.
		/// </para>
		/// </summary>
		public SeriesListFunction GroupByTags(string callback, params string[] tags)
		{
			return new SeriesListFunction("groupByTags", Merge(this, Merge(SingleQuote(callback), tags.Select(SingleQuote).ToArray())));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N and an aggregation function.
		/// Out of all metrics passed, draws only the N metrics with the highest aggregated value over the
		/// time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=highest(server*.instance*.threads.busy,5,'max')
		/// </code>
		/// <para>
		/// Draws the 5 servers with the highest number of busy threads.
		/// </para>
		/// </summary>
		public SeriesListFunction Highest(int n, string func = "average")
		{
			return Ternary("highest", n, SingleQuote(func));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N and an aggregation function.
		/// Out of all metrics passed, draws only the N metrics with the highest aggregated value over the
		/// time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=highest(server*.instance*.threads.busy,5,'max')
		/// </code>
		/// <para>
		/// Draws the 5 servers with the highest number of busy threads.
		/// </para>
		/// </summary>
		public SeriesListFunction Highest(int n)
		{
			return Binary("highest", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Out of all metrics passed, draws only the top N metrics with the highest
		/// average value for the time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=highestAverage(server*.instance*.threads.busy,5)
		/// </code>
		/// <para>
		/// Draws the top 5 servers with the highest average value.
		/// </para>
		/// <para>
		/// This is an alias for :py:func:`highest &lt;highest&gt;` with aggregation ``average``.
		/// </para>
		/// </summary>
		public SeriesListFunction HighestAverage(int n)
		{
			return Binary("highestAverage", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Out of all metrics passed, draws only the N metrics with the highest value
		/// at the end of the time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=highestCurrent(server*.instance*.threads.busy,5)
		/// </code>
		/// <para>
		/// Draws the 5 servers with the highest busy threads.
		/// </para>
		/// <para>
		/// This is an alias for :py:func:`highest &lt;highest&gt;` with aggregation ``current``.
		/// </para>
		/// </summary>
		public SeriesListFunction HighestCurrent(int n)
		{
			return Binary("highestCurrent", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// <para>
		/// Out of all metrics passed, draws only the N metrics with the highest maximum
		/// value in the time period specified.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=highestMax(server*.instance*.threads.busy,5)
		/// </code>
		/// <para>
		/// Draws the top 5 servers who have had the most busy threads during the time
		/// period specified.
		/// </para>
		/// <para>
		/// This is an alias for :py:func:`highest &lt;highest&gt;` with aggregation ``max``.
		/// </para>
		/// </summary>
		public SeriesListFunction HighestMax(int n)
		{
			return Binary("highestMax", n);
		}

		/// <summary>
		/// Estimate hit counts from a list of time series.
		/// <para>
		/// This function assumes the values in each time series represent
		/// hits per second.  It calculates hits per some larger interval
		/// such as per day or per hour.  This function is like summarize(),
		/// except that it compensates automatically for different time scales
		/// (so that a similar graph results from using either fine-grained
		/// or coarse-grained records) and handles rarely-occurring events
		/// gracefully.
		/// </para>
		/// </summary>
		public SeriesListFunction Hitcount(string intervalString, bool alignToInterval = false)
		{
			return Ternary("hitcount", SingleQuote(intervalString), alignToInterval?1:0);
		}

		/// <summary>
		/// Estimate hit counts from a list of time series.
		/// <para>
		/// This function assumes the values in each time series represent
		/// hits per second.  It calculates hits per some larger interval
		/// such as per day or per hour.  This function is like summarize(),
		/// except that it compensates automatically for different time scales
		/// (so that a similar graph results from using either fine-grained
		/// or coarse-grained records) and handles rarely-occurring events
		/// gracefully.
		/// </para>
		/// </summary>
		public SeriesListFunction Hitcount(string intervalString)
		{
			return Binary("hitcount", SingleQuote(intervalString));
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots the
		/// positive or negative deviation of the series data from the forecast.
		/// </summary>
		public SeriesListFunction HoltWintersAberration(int delta = 3, string bootstrapInterval = "7d", string seasonality = "1d")
		{
			return Quaternary("holtWintersAberration", delta, SingleQuote(bootstrapInterval), SingleQuote(seasonality));
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots the
		/// positive or negative deviation of the series data from the forecast.
		/// </summary>
		public SeriesListFunction HoltWintersAberration(int delta = 3, string bootstrapInterval = "7d")
		{
			return Ternary("holtWintersAberration", delta, SingleQuote(bootstrapInterval));
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots the
		/// positive or negative deviation of the series data from the forecast.
		/// </summary>
		public SeriesListFunction HoltWintersAberration(int delta = 3)
		{
			return Binary("holtWintersAberration", delta);
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots the
		/// positive or negative deviation of the series data from the forecast.
		/// </summary>
		public SeriesListFunction HoltWintersAberration()
		{
			return Unary("holtWintersAberration");
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots the
		/// area between the upper and lower bands of the predicted forecast deviations.
		/// </summary>
		public SeriesListFunction HoltWintersConfidenceArea(int delta = 3, string bootstrapInterval = "7d", string seasonality = "1d")
		{
			return Quaternary("holtWintersConfidenceArea", delta, SingleQuote(bootstrapInterval), SingleQuote(seasonality));
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots the
		/// area between the upper and lower bands of the predicted forecast deviations.
		/// </summary>
		public SeriesListFunction HoltWintersConfidenceArea(int delta = 3, string bootstrapInterval = "7d")
		{
			return Ternary("holtWintersConfidenceArea", delta, SingleQuote(bootstrapInterval));
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots the
		/// area between the upper and lower bands of the predicted forecast deviations.
		/// </summary>
		public SeriesListFunction HoltWintersConfidenceArea(int delta = 3)
		{
			return Binary("holtWintersConfidenceArea", delta);
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots the
		/// area between the upper and lower bands of the predicted forecast deviations.
		/// </summary>
		public SeriesListFunction HoltWintersConfidenceArea()
		{
			return Unary("holtWintersConfidenceArea");
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots
		/// upper and lower bands with the predicted forecast deviations.
		/// </summary>
		public SeriesListFunction HoltWintersConfidenceBands(int delta = 3, string bootstrapInterval = "7d", string seasonality = "1d")
		{
			return Quaternary("holtWintersConfidenceBands", delta, SingleQuote(bootstrapInterval), SingleQuote(seasonality));
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots
		/// upper and lower bands with the predicted forecast deviations.
		/// </summary>
		public SeriesListFunction HoltWintersConfidenceBands(int delta = 3, string bootstrapInterval = "7d")
		{
			return Ternary("holtWintersConfidenceBands", delta, SingleQuote(bootstrapInterval));
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots
		/// upper and lower bands with the predicted forecast deviations.
		/// </summary>
		public SeriesListFunction HoltWintersConfidenceBands(int delta = 3)
		{
			return Binary("holtWintersConfidenceBands", delta);
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data and plots
		/// upper and lower bands with the predicted forecast deviations.
		/// </summary>
		public SeriesListFunction HoltWintersConfidenceBands()
		{
			return Unary("holtWintersConfidenceBands");
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data. Data from
		/// `bootstrapInterval` (one week by default) previous to the series is used to bootstrap the initial forecast.
		/// </summary>
		public SeriesListFunction HoltWintersForecast(string bootstrapInterval = "7d", string seasonality = "1d")
		{
			return Ternary("holtWintersForecast", SingleQuote(bootstrapInterval), SingleQuote(seasonality));
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data. Data from
		/// `bootstrapInterval` (one week by default) previous to the series is used to bootstrap the initial forecast.
		/// </summary>
		public SeriesListFunction HoltWintersForecast(string bootstrapInterval = "7d")
		{
			return Binary("holtWintersForecast", SingleQuote(bootstrapInterval));
		}

		/// <summary>
		/// Performs a Holt-Winters forecast using the series as input data. Data from
		/// `bootstrapInterval` (one week by default) previous to the series is used to bootstrap the initial forecast.
		/// </summary>
		public SeriesListFunction HoltWintersForecast()
		{
			return Unary("holtWintersForecast");
		}

		/// <summary>
		/// This will show the sum over time, sort of like a continuous addition function.
		/// Useful for finding totals or trends in metrics that are collected per minute.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=integral(company.sales.perMinute)
		/// </code>
		/// <para>
		/// This would start at zero on the left side of the graph, adding the sales each
		/// minute, and show the total sales for the time period selected at the right
		/// side, (time now, or the time specified by '&amp;until=').
		/// </para>
		/// </summary>
		public SeriesListFunction Integral()
		{
			return Unary("integral");
		}

		/// <summary>
		/// This will do the same as integral() funcion, except resetting the total to 0
		/// at the given time in the parameter "from"
		/// Useful for finding totals per hour/day/week/..
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=integralByInterval(company.sales.perMinute, "1d")&amp;from=midnight-10days
		/// </code>
		/// <para>
		/// This would start at zero on the left side of the graph, adding the sales each
		/// minute, and show the evolution of sales per day during the last 10 days.
		/// </para>
		/// </summary>
		public SeriesListFunction IntegralByInterval(string intervalUnit)
		{
			return Binary("integralByInterval", SingleQuote(intervalUnit));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, and optionally a limit to the number of 'None' values to skip over.
		/// Continues the line with the last received value when gaps ('None' values) appear in your data, rather than breaking your line.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=interpolate(Server01.connections.handled)
		///   &amp;target=interpolate(Server01.connections.handled, 10)
		/// </code>
		/// </summary>
		public SeriesListFunction Interpolate(int limit = Int32.MaxValue)
		{
			return Binary("interpolate", limit);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, and optionally a limit to the number of 'None' values to skip over.
		/// Continues the line with the last received value when gaps ('None' values) appear in your data, rather than breaking your line.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=interpolate(Server01.connections.handled)
		///   &amp;target=interpolate(Server01.connections.handled, 10)
		/// </code>
		/// </summary>
		public SeriesListFunction Interpolate()
		{
			return Unary("interpolate");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, and inverts each datapoint (i.e. 1/x).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=invert(Server.instance01.threads.busy)
		/// </code>
		/// </summary>
		public SeriesListFunction Invert()
		{
			return Unary("invert");
		}

		/// <summary>
		/// Takes a metric or wildcard seriesList and counts up the number of non-null
		/// values.  This is useful for understanding the number of metrics that have data
		/// at a given point in time (i.e. to count which servers are alive).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=isNonNull(webapp.pages.*.views)
		/// </code>
		/// <para>
		/// Returns a seriesList where 1 is specified for non-null values, and
		/// 0 is specified for null values.
		/// </para>
		/// </summary>
		public SeriesListFunction IsNonNull()
		{
			return Unary("isNonNull");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, and optionally a limit to the number of 'None' values to skip over.
		/// Continues the line with the last received value when gaps ('None' values) appear in your data, rather than breaking your line.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=keepLastValue(Server01.connections.handled)
		///   &amp;target=keepLastValue(Server01.connections.handled, 10)
		/// </code>
		/// </summary>
		public SeriesListFunction KeepLastValue(int limit = Int32.MaxValue)
		{
			return Binary("keepLastValue", limit);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, and optionally a limit to the number of 'None' values to skip over.
		/// Continues the line with the last received value when gaps ('None' values) appear in your data, rather than breaking your line.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=keepLastValue(Server01.connections.handled)
		///   &amp;target=keepLastValue(Server01.connections.handled, 10)
		/// </code>
		/// </summary>
		public SeriesListFunction KeepLastValue()
		{
			return Unary("keepLastValue");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList and a string in quotes.
		/// Appends a value to the metric name in the legend.  Currently one or several of: `last`, `avg`,
		/// `total`, `min`, `max`.
		/// The last argument can be `si` (default) or `binary`, in that case values will be formatted in the
		/// corresponding system.
		/// <code>
		///   &amp;target=legendValue(Sales.widgets.largeBlue, 'avg', 'max', 'si')
		/// </code>
		/// </summary>
		public SeriesListFunction LegendValue(params string[] valuesTypes)
		{
			return new SeriesListFunction("legendValue", Merge(this, valuesTypes.Select(SingleQuote).ToArray()));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList and a string in quotes.
		/// Appends a value to the metric name in the legend.  Currently one or several of: `last`, `avg`,
		/// `total`, `min`, `max`.
		/// The last argument can be `si` (default) or `binary`, in that case values will be formatted in the
		/// corresponding system.
		/// <code>
		///   &amp;target=legendValue(Sales.widgets.largeBlue, 'avg', 'max', 'si')
		/// </code>
		/// </summary>
		public SeriesListFunction LegendValue()
		{
			return Unary("legendValue");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// <para>
		/// Only draw the first N metrics.  Useful when testing a wildcard in a metric.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=limit(server*.instance*.memory.free,5)
		/// </code>
		/// <para>
		/// Draws only the first 5 instance's memory free.
		/// </para>
		/// </summary>
		public SeriesListFunction Limit(int n)
		{
			return Binary("limit", n);
		}

		/// <summary>
		/// Graphs the linear regression function by least squares method.
		/// <para>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// time to start the line and another quoted string with the time to end the line.
		/// The start and end times are inclusive (default range is from to until). See
		/// ``from / until`` in the render\_api_ for examples of time formats. Datapoints
		/// in the range is used to regression.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=linearRegression(Server.instance01.threads.busy, '-1d')
		///   &amp;target=linearRegression(Server.instance*.threads.busy, "00:00 20140101","11:59 20140630")
		/// </code>
		/// </summary>
		public SeriesListFunction LinearRegression(string startSourceAt = null, string endSourceAt = null)
		{
			return Ternary("linearRegression", SingleQuote(startSourceAt), SingleQuote(endSourceAt));
		}

		/// <summary>
		/// Graphs the linear regression function by least squares method.
		/// <para>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// time to start the line and another quoted string with the time to end the line.
		/// The start and end times are inclusive (default range is from to until). See
		/// ``from / until`` in the render\_api_ for examples of time formats. Datapoints
		/// in the range is used to regression.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=linearRegression(Server.instance01.threads.busy, '-1d')
		///   &amp;target=linearRegression(Server.instance*.threads.busy, "00:00 20140101","11:59 20140630")
		/// </code>
		/// </summary>
		public SeriesListFunction LinearRegression(string startSourceAt = null)
		{
			return Binary("linearRegression", SingleQuote(startSourceAt));
		}

		/// <summary>
		/// Graphs the linear regression function by least squares method.
		/// <para>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// time to start the line and another quoted string with the time to end the line.
		/// The start and end times are inclusive (default range is from to until). See
		/// ``from / until`` in the render\_api_ for examples of time formats. Datapoints
		/// in the range is used to regression.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=linearRegression(Server.instance01.threads.busy, '-1d')
		///   &amp;target=linearRegression(Server.instance*.threads.busy, "00:00 20140101","11:59 20140630")
		/// </code>
		/// </summary>
		public SeriesListFunction LinearRegression()
		{
			return Unary("linearRegression");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a float F.
		/// <para>
		/// Draw the selected metrics with a line width of F, overriding the default
		/// value of 1, or the &amp;lineWidth=X.X parameter.
		/// </para>
		/// <para>
		/// Useful for highlighting a single metric out of many, or having multiple
		/// line widths in one graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=lineWidth(server01.instance01.memory.free,5)
		/// </code>
		/// </summary>
		public SeriesListFunction LineWidth(double width)
		{
			return Binary("lineWidth", width.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, a base, and draws the y-axis in logarithmic
		/// format.  If base is omitted, the function defaults to base 10.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=log(carbon.agents.hostname.avgUpdateTime,2)
		/// </code>
		/// </summary>
		public SeriesListFunction Log(int @base = 10)
		{
			return Binary("log", @base);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, a base, and draws the y-axis in logarithmic
		/// format.  If base is omitted, the function defaults to base 10.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=log(carbon.agents.hostname.avgUpdateTime,2)
		/// </code>
		/// </summary>
		public SeriesListFunction Log()
		{
			return Unary("log");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N and an aggregation function.
		/// Out of all metrics passed, draws only the N metrics with the lowest aggregated value over the
		/// time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=lowest(server*.instance*.threads.busy,5,'min')
		/// </code>
		/// <para>
		/// Draws the 5 servers with the lowest number of busy threads.
		/// </para>
		/// </summary>
		public SeriesListFunction Lowest(int n, string func = "average")
		{
			return Ternary("lowest", n, SingleQuote(func));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N and an aggregation function.
		/// Out of all metrics passed, draws only the N metrics with the lowest aggregated value over the
		/// time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=lowest(server*.instance*.threads.busy,5,'min')
		/// </code>
		/// <para>
		/// Draws the 5 servers with the lowest number of busy threads.
		/// </para>
		/// </summary>
		public SeriesListFunction Lowest(int n)
		{
			return Binary("lowest", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Out of all metrics passed, draws only the bottom N metrics with the lowest
		/// average value for the time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=lowestAverage(server*.instance*.threads.busy,5)
		/// </code>
		/// <para>
		/// Draws the bottom 5 servers with the lowest average value.
		/// </para>
		/// <para>
		/// This is an alias for :py:func:`lowest &lt;lowest&gt;` with aggregation ``average``.
		/// </para>
		/// </summary>
		public SeriesListFunction LowestAverage(int n)
		{
			return Binary("lowestAverage", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Out of all metrics passed, draws only the N metrics with the lowest value at
		/// the end of the time period specified.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=lowestCurrent(server*.instance*.threads.busy,5)
		/// </code>
		/// <para>
		/// Draws the 5 servers with the least busy threads right now.
		/// </para>
		/// <para>
		/// This is an alias for :py:func:`lowest &lt;lowest&gt;` with aggregation ``current``.
		/// </para>
		/// </summary>
		public SeriesListFunction LowestCurrent(int n)
		{
			return Binary("lowestCurrent", n);
		}

		/// <summary>
		/// Short form: ``map()``
		/// <para>
		/// Takes a seriesList and maps it to a list of seriesList. Each seriesList has the
		/// given mapNodes in common.
		/// </para>
		/// <para>
		/// .. note:: This function is not very useful alone. It should be used with :py:func:`reduceSeries`
		/// </para>
		/// <code>
		///   mapSeries(servers.*.cpu.*,1) =&gt;
		/// </code>
		/// <para>
		///     [
		///       servers.server1.cpu.*,
		///       servers.server2.cpu.*,
		///       ...
		///       servers.serverN.cpu.*
		///     ]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// </summary>
		public SeriesListFunction Map(params uint[] mapNodes)
		{
			return new SeriesListFunction("map", Merge(this, mapNodes));
		}

		/// <summary>
		/// Short form: ``map()``
		/// <para>
		/// Takes a seriesList and maps it to a list of seriesList. Each seriesList has the
		/// given mapNodes in common.
		/// </para>
		/// <para>
		/// .. note:: This function is not very useful alone. It should be used with :py:func:`reduceSeries`
		/// </para>
		/// <code>
		///   mapSeries(servers.*.cpu.*,1) =&gt;
		/// </code>
		/// <para>
		///     [
		///       servers.server1.cpu.*,
		///       servers.server2.cpu.*,
		///       ...
		///       servers.serverN.cpu.*
		///     ]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// </summary>
		public SeriesListFunction Map(params string[] mapNodes)
		{
			return new SeriesListFunction("map", Merge(this, mapNodes.Select(SingleQuote).ToArray()));
		}

		/// <summary>
		/// Short form: ``map()``
		/// <para>
		/// Takes a seriesList and maps it to a list of seriesList. Each seriesList has the
		/// given mapNodes in common.
		/// </para>
		/// <para>
		/// .. note:: This function is not very useful alone. It should be used with :py:func:`reduceSeries`
		/// </para>
		/// <code>
		///   mapSeries(servers.*.cpu.*,1) =&gt;
		/// </code>
		/// <para>
		///     [
		///       servers.server1.cpu.*,
		///       servers.server2.cpu.*,
		///       ...
		///       servers.serverN.cpu.*
		///     ]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// </summary>
		public SeriesListFunction MapSeries(params uint[] mapNodes)
		{
			return new SeriesListFunction("mapSeries", Merge(this, mapNodes));
		}

		/// <summary>
		/// Short form: ``map()``
		/// <para>
		/// Takes a seriesList and maps it to a list of seriesList. Each seriesList has the
		/// given mapNodes in common.
		/// </para>
		/// <para>
		/// .. note:: This function is not very useful alone. It should be used with :py:func:`reduceSeries`
		/// </para>
		/// <code>
		///   mapSeries(servers.*.cpu.*,1) =&gt;
		/// </code>
		/// <para>
		///     [
		///       servers.server1.cpu.*,
		///       servers.server2.cpu.*,
		///       ...
		///       servers.serverN.cpu.*
		///     ]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// </summary>
		public SeriesListFunction MapSeries(params string[] mapNodes)
		{
			return new SeriesListFunction("mapSeries", Merge(this, mapNodes.Select(SingleQuote).ToArray()));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by a constant n.
		/// Draws only the metrics with a maximum value above n.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=maximumAbove(system.interface.eth*.packetsSent,1000)
		/// </code>
		/// <para>
		/// This would only display interfaces which sent more than 1000 packets/min.
		/// </para>
		/// </summary>
		public SeriesListFunction MaximumAbove(int n)
		{
			return Binary("maximumAbove", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by a constant n.
		/// Draws only the metrics with a maximum value below n.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=maximumBelow(system.interface.eth*.packetsSent,1000)
		/// </code>
		/// <para>
		/// This would only display interfaces which sent less than 1000 packets/min.
		/// </para>
		/// </summary>
		public SeriesListFunction MaximumBelow(int n)
		{
			return Binary("maximumBelow", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// For each datapoint from each metric passed in, pick the maximum value and graph it.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=maxSeries(Server*.connections.total)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``max``.
		/// </para>
		/// </summary>
		public SeriesListFunction MaxSeries(params SeriesListBase[] seriesLists)
		{
			return Multiple("maxSeries", seriesLists);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by a constant n.
		/// Draws only the metrics with a minimum value above n.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=minimumAbove(system.interface.eth*.packetsSent,1000)
		/// </code>
		/// <para>
		/// This would only display interfaces which sent more than 1000 packets/min.
		/// </para>
		/// </summary>
		public SeriesListFunction MinimumAbove(int n)
		{
			return Binary("minimumAbove", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by a constant n.
		/// Draws only the metrics with a minimum value below n.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=minimumBelow(system.interface.eth*.packetsSent,1000)
		/// </code>
		/// <para>
		/// This would only display interfaces which at one point sent less than 1000 packets/min.
		/// </para>
		/// </summary>
		public SeriesListFunction MinimumBelow(int n)
		{
			return Binary("minimumBelow", n);
		}

		/// <summary>
		/// Applies the popular min max normalization technique, which takes
		/// each point and applies the following normalization transformation
		/// to it: normalized = (point - min) / (max - min).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=minMax(Server.instance01.threads.busy)
		/// </code>
		/// </summary>
		public SeriesListFunction MinMax()
		{
			return Unary("minMax");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// For each datapoint from each metric passed in, pick the minimum value and graph it.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=minSeries(Server*.connections.total)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``min``.
		/// </para>
		/// </summary>
		public SeriesListFunction MinSeries(params SeriesListBase[] seriesLists)
		{
			return Multiple("minSeries", seriesLists);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Draws the N most deviant metrics.
		/// To find the deviants, the standard deviation (sigma) of each series
		/// is taken and ranked. The top N standard deviations are returned.
		/// <para>
		///   Example:
		/// </para>
		/// <code>
		///   &amp;target=mostDeviant(server*.instance*.memory.free, 5)
		/// </code>
		/// <para>
		/// Draws the 5 instances furthest from the average memory free.
		/// </para>
		/// </summary>
		public SeriesListFunction MostDeviant(int n)
		{
			return Binary("mostDeviant", n);
		}

		/// <summary>
		/// Graphs the moving average of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// average of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingAverage(Server.instance01.threads.busy,10)
		///   &amp;target=movingAverage(Server.instance*.threads.idle,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingAverage(int windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingAverage", windowSize, xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving average of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// average of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingAverage(Server.instance01.threads.busy,10)
		///   &amp;target=movingAverage(Server.instance*.threads.idle,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingAverage(string windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingAverage", SingleQuote(windowSize), xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving average of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// average of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingAverage(Server.instance01.threads.busy,10)
		///   &amp;target=movingAverage(Server.instance*.threads.idle,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingAverage(string windowSize)
		{
			return Binary("movingAverage", SingleQuote(windowSize));
		}

		/// <summary>
		/// Graphs the moving maximum of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// maximum of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingMax(Server.instance01.requests,10)
		///   &amp;target=movingMax(Server.instance*.errors,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingMax(int windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingMax", windowSize, xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving maximum of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// maximum of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingMax(Server.instance01.requests,10)
		///   &amp;target=movingMax(Server.instance*.errors,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingMax(string windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingMax", SingleQuote(windowSize), xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving maximum of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// maximum of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingMax(Server.instance01.requests,10)
		///   &amp;target=movingMax(Server.instance*.errors,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingMax(string windowSize)
		{
			return Binary("movingMax", SingleQuote(windowSize));
		}

		/// <summary>
		/// Graphs the moving median of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// median of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingMedian(Server.instance01.threads.busy,10)
		///   &amp;target=movingMedian(Server.instance*.threads.idle,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingMedian(int windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingMedian", windowSize, xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving median of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// median of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingMedian(Server.instance01.threads.busy,10)
		///   &amp;target=movingMedian(Server.instance*.threads.idle,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingMedian(string windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingMedian", SingleQuote(windowSize), xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving median of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// median of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingMedian(Server.instance01.threads.busy,10)
		///   &amp;target=movingMedian(Server.instance*.threads.idle,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingMedian(string windowSize)
		{
			return Binary("movingMedian", SingleQuote(windowSize));
		}

		/// <summary>
		/// Graphs the moving minimum of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// minimum of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingMin(Server.instance01.requests,10)
		///   &amp;target=movingMin(Server.instance*.errors,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingMin(int windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingMin", windowSize, xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving minimum of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// minimum of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingMin(Server.instance01.requests,10)
		///   &amp;target=movingMin(Server.instance*.errors,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingMin(string windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingMin", SingleQuote(windowSize), xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving minimum of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// minimum of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingMin(Server.instance01.requests,10)
		///   &amp;target=movingMin(Server.instance*.errors,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingMin(string windowSize)
		{
			return Binary("movingMin", SingleQuote(windowSize));
		}

		/// <summary>
		/// Graphs the moving sum of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// sum of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingSum(Server.instance01.requests,10)
		///   &amp;target=movingSum(Server.instance*.errors,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingSum(int windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingSum", windowSize, xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving sum of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// sum of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingSum(Server.instance01.requests,10)
		///   &amp;target=movingSum(Server.instance*.errors,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingSum(string windowSize, double? xFilesFactor = null)
		{
			return Ternary("movingSum", SingleQuote(windowSize), xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs the moving sum of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList followed by a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), and an xFilesFactor value to specify
		/// how many points in the window must be non-null for the output to be considered valid. Graphs the
		/// sum of the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingSum(Server.instance01.requests,10)
		///   &amp;target=movingSum(Server.instance*.errors,'5min')
		/// </code>
		/// </summary>
		public SeriesListFunction MovingSum(string windowSize)
		{
			return Binary("movingSum", SingleQuote(windowSize));
		}

		/// <summary>
		/// Graphs a moving window function of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList, a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), a function to apply to the points
		/// in the window to produce the output, and an xFilesFactor value to specify how many points in the
		/// window must be non-null for the output to be considered valid. Graphs the
		/// output of the function for the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingWindow(Server.instance01.threads.busy,10)
		///   &amp;target=movingWindow(Server.instance*.threads.idle,'5min','median',0.5)
		/// </code>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   `xFilesFactor` follows the same semantics as in Whisper storage schemas.  Setting it to 0 (the
		///   default) means that only a single value in a given interval needs to be non-null, setting it to
		///   1 means that all values in the interval must be non-null.  A setting of 0.5 means that at least
		///   half the values in the interval must be non-null.
		/// </para>
		/// </summary>
		public SeriesListFunction MovingWindow(int windowSize, string func = "average", double? xFilesFactor = null)
		{
			return Quaternary("movingWindow", windowSize, SingleQuote(func), xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs a moving window function of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList, a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), a function to apply to the points
		/// in the window to produce the output, and an xFilesFactor value to specify how many points in the
		/// window must be non-null for the output to be considered valid. Graphs the
		/// output of the function for the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingWindow(Server.instance01.threads.busy,10)
		///   &amp;target=movingWindow(Server.instance*.threads.idle,'5min','median',0.5)
		/// </code>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   `xFilesFactor` follows the same semantics as in Whisper storage schemas.  Setting it to 0 (the
		///   default) means that only a single value in a given interval needs to be non-null, setting it to
		///   1 means that all values in the interval must be non-null.  A setting of 0.5 means that at least
		///   half the values in the interval must be non-null.
		/// </para>
		/// </summary>
		public SeriesListFunction MovingWindow(string windowSize, string func = "average", double? xFilesFactor = null)
		{
			return Quaternary("movingWindow", SingleQuote(windowSize), SingleQuote(func), xFilesFactor?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Graphs a moving window function of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList, a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), a function to apply to the points
		/// in the window to produce the output, and an xFilesFactor value to specify how many points in the
		/// window must be non-null for the output to be considered valid. Graphs the
		/// output of the function for the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingWindow(Server.instance01.threads.busy,10)
		///   &amp;target=movingWindow(Server.instance*.threads.idle,'5min','median',0.5)
		/// </code>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   `xFilesFactor` follows the same semantics as in Whisper storage schemas.  Setting it to 0 (the
		///   default) means that only a single value in a given interval needs to be non-null, setting it to
		///   1 means that all values in the interval must be non-null.  A setting of 0.5 means that at least
		///   half the values in the interval must be non-null.
		/// </para>
		/// </summary>
		public SeriesListFunction MovingWindow(string windowSize, string func = "average")
		{
			return Ternary("movingWindow", SingleQuote(windowSize), SingleQuote(func));
		}

		/// <summary>
		/// Graphs a moving window function of a metric (or metrics) over a fixed number of
		/// past points, or a time interval.
		/// <para>
		/// Takes one metric or a wildcard seriesList, a number N of datapoints
		/// or a quoted string with a length of time like '1hour' or '5min' (See ``from /
		/// until`` in the render\_api_ for examples of time formats), a function to apply to the points
		/// in the window to produce the output, and an xFilesFactor value to specify how many points in the
		/// window must be non-null for the output to be considered valid. Graphs the
		/// output of the function for the preceeding datapoints for each point on the graph.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=movingWindow(Server.instance01.threads.busy,10)
		///   &amp;target=movingWindow(Server.instance*.threads.idle,'5min','median',0.5)
		/// </code>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   `xFilesFactor` follows the same semantics as in Whisper storage schemas.  Setting it to 0 (the
		///   default) means that only a single value in a given interval needs to be non-null, setting it to
		///   1 means that all values in the interval must be non-null.  A setting of 0.5 means that at least
		///   half the values in the interval must be non-null.
		/// </para>
		/// </summary>
		public SeriesListFunction MovingWindow(string windowSize)
		{
			return Binary("movingWindow", SingleQuote(windowSize));
		}

		/// <summary>
		/// Takes two or more series and multiplies their points. A constant may not be
		/// used. To multiply by a constant, use the scale() function.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=multiplySeries(Series.dividends,Series.divisors)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``multiply``.
		/// </para>
		/// </summary>
		public SeriesListFunction MultiplySeries(params SeriesListBase[] seriesLists)
		{
			return Multiple("multiplySeries", seriesLists);
		}

		/// <summary>
		/// Call multiplySeries after inserting wildcards at the given position(s).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=multiplySeriesWithWildcards(web.host-[0-7].{avg-response,total-request}.value, 2)
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=multiplySeries(web.host-0.{avg-response,total-request}.value)&amp;target=multiplySeries(web.host-1.{avg-response,total-request}.value)...
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregateWithWildcards &lt;aggregateWithWildcards&gt;` with aggregation ``multiply``.
		/// </para>
		/// </summary>
		public SeriesListFunction MultiplySeriesWithWildcards(params uint[] position)
		{
			return new SeriesListFunction("multiplySeriesWithWildcards", Merge(this, position));
		}

		/// <summary>
		/// Call multiplySeries after inserting wildcards at the given position(s).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=multiplySeriesWithWildcards(web.host-[0-7].{avg-response,total-request}.value, 2)
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=multiplySeries(web.host-0.{avg-response,total-request}.value)&amp;target=multiplySeries(web.host-1.{avg-response,total-request}.value)...
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregateWithWildcards &lt;aggregateWithWildcards&gt;` with aggregation ``multiply``.
		/// </para>
		/// </summary>
		public SeriesListFunction MultiplySeriesWithWildcards()
		{
			return Unary("multiplySeriesWithWildcards");
		}

		/// <summary>
		/// Same as the derivative function above, but ignores datapoints that trend
		/// down.  Useful for counters that increase for a long time, then wrap or
		/// reset. (Such as if a network interface is destroyed and recreated by unloading
		/// and re-loading a kernel module, common with USB / WiFi cards.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=nonNegativederivative(company.server.application01.ifconfig.TXPackets)
		/// </code>
		/// </summary>
		public SeriesListFunction NonNegativeDerivative(double? maxValue = null)
		{
			return Binary("nonNegativeDerivative", maxValue?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Same as the derivative function above, but ignores datapoints that trend
		/// down.  Useful for counters that increase for a long time, then wrap or
		/// reset. (Such as if a network interface is destroyed and recreated by unloading
		/// and re-loading a kernel module, common with USB / WiFi cards.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=nonNegativederivative(company.server.application01.ifconfig.TXPackets)
		/// </code>
		/// </summary>
		public SeriesListFunction NonNegativeDerivative()
		{
			return Unary("nonNegativeDerivative");
		}

		/// <summary>
		/// Returns n-percent of each series in the seriesList.
		/// </summary>
		public SeriesListFunction NPercentile(int n)
		{
			return Binary("nPercentile", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by a constant, and adds the constant to
		/// each datapoint.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=offset(Server.instance01.threads.busy,10)
		/// </code>
		/// </summary>
		public SeriesListFunction Offset(double factor)
		{
			return Binary("offset", factor.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Offsets a metric or wildcard seriesList by subtracting the minimum
		/// value in the series from each datapoint.
		/// <para>
		/// Useful to compare different series where the values in each series
		/// may be higher or lower on average but you're only interested in the
		/// relative difference.
		/// </para>
		/// <para>
		/// An example use case is for comparing different round trip time
		/// results. When measuring RTT (like pinging a server), different
		/// devices may come back with consistently different results due to
		/// network latency which will be different depending on how many
		/// network hops between the probe and the device. To compare different
		/// devices in the same graph, the network latency to each has to be
		/// factored out of the results. This is a shortcut that takes the
		/// fastest response (lowest number in the series) and sets that to zero
		/// and then offsets all of the other datapoints in that series by that
		/// amount. This makes the assumption that the lowest response is the
		/// fastest the device can respond, of course the more datapoints that
		/// are in the series the more accurate this assumption is.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=offsetToZero(Server.instance01.responseTime)
		///   &amp;target=offsetToZero(Server.instance*.responseTime)
		/// </code>
		/// </summary>
		public SeriesListFunction OffsetToZero()
		{
			return Unary("offsetToZero");
		}

		/// <summary>
		/// Calculates a percentage of the total of a wildcard series. If `total` is specified,
		/// each series will be calculated as a percentage of that total. If `total` is not specified,
		/// the sum of all points in the wildcard series will be used instead.
		/// <para>
		/// A list of nodes can optionally be provided, if so they will be used to match series with their
		/// corresponding totals following the same logic as :py:func:`groupByNodes &lt;groupByNodes&gt;`.
		/// </para>
		/// <para>
		/// When passing `nodes` the `total` parameter may be a series list or `None`.  If it is `None` then
		/// for each series in `seriesList` the percentage of the sum of series in that group will be returned.
		/// </para>
		/// <para>
		/// When not passing `nodes`, the `total` parameter may be a single series, reference the same number
		/// of series as `seriesList` or be a numeric value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   # Server01 connections failed and succeeded as a percentage of Server01 connections attempted
		///   &amp;target=asPercent(Server01.connections.{failed,succeeded}, Server01.connections.attempted)
		/// </code>
		/// <para>
		///   # For each server, its connections failed as a percentage of its connections attempted
		///   &amp;target=asPercent(Server*.connections.failed, Server*.connections.attempted)
		/// </para>
		/// <para>
		///   # For each server, its connections failed and succeeded as a percentage of its connections attemped
		///   &amp;target=asPercent(Server*.connections.{failed,succeeded}, Server*.connections.attempted, 0)
		/// </para>
		/// <para>
		///   # apache01.threads.busy as a percentage of 1500
		///   &amp;target=asPercent(apache01.threads.busy,1500)
		/// </para>
		/// <para>
		///   # Server01 cpu stats as a percentage of its total
		///   &amp;target=asPercent(Server01.cpu.*.jiffies)
		/// </para>
		/// <para>
		///   # cpu stats for each server as a percentage of its total
		///   &amp;target=asPercent(Server*.cpu.*.jiffies, None, 0)
		/// </para>
		/// <para>
		/// When using `nodes`, any series or totals that can't be matched will create output series with
		/// names like ``asPercent(someSeries,MISSING)`` or ``asPercent(MISSING,someTotalSeries)`` and all
		/// values set to None. If desired these series can be filtered out by piping the result through
		/// ``|exclude("MISSING")`` as shown below:
		/// </para>
		/// <code>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)
		/// </code>
		/// <para>
		///   # will produce 3 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		///   # asPercent(Server2.memory.used,MISSING) [all values will be None]
		///   # asPercent(MISSING,Server3.memory.total) [all values will be None]
		/// </para>
		/// <para>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)|exclude("MISSING")
		/// </para>
		/// <para>
		///   # will produce 1 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   When `total` is a seriesList, specifying `nodes` to match series with the corresponding total
		///   series will increase reliability.
		/// </para>
		/// </summary>
		public SeriesListFunction Pct(SeriesListBase total = null, params uint[] nodes)
		{
			return new SeriesListFunction("pct", Merge(this, Merge(total, nodes)));
		}

		/// <summary>
		/// Calculates a percentage of the total of a wildcard series. If `total` is specified,
		/// each series will be calculated as a percentage of that total. If `total` is not specified,
		/// the sum of all points in the wildcard series will be used instead.
		/// <para>
		/// A list of nodes can optionally be provided, if so they will be used to match series with their
		/// corresponding totals following the same logic as :py:func:`groupByNodes &lt;groupByNodes&gt;`.
		/// </para>
		/// <para>
		/// When passing `nodes` the `total` parameter may be a series list or `None`.  If it is `None` then
		/// for each series in `seriesList` the percentage of the sum of series in that group will be returned.
		/// </para>
		/// <para>
		/// When not passing `nodes`, the `total` parameter may be a single series, reference the same number
		/// of series as `seriesList` or be a numeric value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   # Server01 connections failed and succeeded as a percentage of Server01 connections attempted
		///   &amp;target=asPercent(Server01.connections.{failed,succeeded}, Server01.connections.attempted)
		/// </code>
		/// <para>
		///   # For each server, its connections failed as a percentage of its connections attempted
		///   &amp;target=asPercent(Server*.connections.failed, Server*.connections.attempted)
		/// </para>
		/// <para>
		///   # For each server, its connections failed and succeeded as a percentage of its connections attemped
		///   &amp;target=asPercent(Server*.connections.{failed,succeeded}, Server*.connections.attempted, 0)
		/// </para>
		/// <para>
		///   # apache01.threads.busy as a percentage of 1500
		///   &amp;target=asPercent(apache01.threads.busy,1500)
		/// </para>
		/// <para>
		///   # Server01 cpu stats as a percentage of its total
		///   &amp;target=asPercent(Server01.cpu.*.jiffies)
		/// </para>
		/// <para>
		///   # cpu stats for each server as a percentage of its total
		///   &amp;target=asPercent(Server*.cpu.*.jiffies, None, 0)
		/// </para>
		/// <para>
		/// When using `nodes`, any series or totals that can't be matched will create output series with
		/// names like ``asPercent(someSeries,MISSING)`` or ``asPercent(MISSING,someTotalSeries)`` and all
		/// values set to None. If desired these series can be filtered out by piping the result through
		/// ``|exclude("MISSING")`` as shown below:
		/// </para>
		/// <code>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)
		/// </code>
		/// <para>
		///   # will produce 3 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		///   # asPercent(Server2.memory.used,MISSING) [all values will be None]
		///   # asPercent(MISSING,Server3.memory.total) [all values will be None]
		/// </para>
		/// <para>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)|exclude("MISSING")
		/// </para>
		/// <para>
		///   # will produce 1 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   When `total` is a seriesList, specifying `nodes` to match series with the corresponding total
		///   series will increase reliability.
		/// </para>
		/// </summary>
		public SeriesListFunction Pct(SeriesListBase total = null, params string[] nodes)
		{
			return new SeriesListFunction("pct", Merge(this, Merge(total, nodes.Select(SingleQuote).ToArray())));
		}

		/// <summary>
		/// Calculates a percentage of the total of a wildcard series. If `total` is specified,
		/// each series will be calculated as a percentage of that total. If `total` is not specified,
		/// the sum of all points in the wildcard series will be used instead.
		/// <para>
		/// A list of nodes can optionally be provided, if so they will be used to match series with their
		/// corresponding totals following the same logic as :py:func:`groupByNodes &lt;groupByNodes&gt;`.
		/// </para>
		/// <para>
		/// When passing `nodes` the `total` parameter may be a series list or `None`.  If it is `None` then
		/// for each series in `seriesList` the percentage of the sum of series in that group will be returned.
		/// </para>
		/// <para>
		/// When not passing `nodes`, the `total` parameter may be a single series, reference the same number
		/// of series as `seriesList` or be a numeric value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   # Server01 connections failed and succeeded as a percentage of Server01 connections attempted
		///   &amp;target=asPercent(Server01.connections.{failed,succeeded}, Server01.connections.attempted)
		/// </code>
		/// <para>
		///   # For each server, its connections failed as a percentage of its connections attempted
		///   &amp;target=asPercent(Server*.connections.failed, Server*.connections.attempted)
		/// </para>
		/// <para>
		///   # For each server, its connections failed and succeeded as a percentage of its connections attemped
		///   &amp;target=asPercent(Server*.connections.{failed,succeeded}, Server*.connections.attempted, 0)
		/// </para>
		/// <para>
		///   # apache01.threads.busy as a percentage of 1500
		///   &amp;target=asPercent(apache01.threads.busy,1500)
		/// </para>
		/// <para>
		///   # Server01 cpu stats as a percentage of its total
		///   &amp;target=asPercent(Server01.cpu.*.jiffies)
		/// </para>
		/// <para>
		///   # cpu stats for each server as a percentage of its total
		///   &amp;target=asPercent(Server*.cpu.*.jiffies, None, 0)
		/// </para>
		/// <para>
		/// When using `nodes`, any series or totals that can't be matched will create output series with
		/// names like ``asPercent(someSeries,MISSING)`` or ``asPercent(MISSING,someTotalSeries)`` and all
		/// values set to None. If desired these series can be filtered out by piping the result through
		/// ``|exclude("MISSING")`` as shown below:
		/// </para>
		/// <code>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)
		/// </code>
		/// <para>
		///   # will produce 3 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		///   # asPercent(Server2.memory.used,MISSING) [all values will be None]
		///   # asPercent(MISSING,Server3.memory.total) [all values will be None]
		/// </para>
		/// <para>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)|exclude("MISSING")
		/// </para>
		/// <para>
		///   # will produce 1 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   When `total` is a seriesList, specifying `nodes` to match series with the corresponding total
		///   series will increase reliability.
		/// </para>
		/// </summary>
		public SeriesListFunction Pct(SeriesListBase total = null)
		{
			return Binary("pct", total);
		}

		/// <summary>
		/// Calculates a percentage of the total of a wildcard series. If `total` is specified,
		/// each series will be calculated as a percentage of that total. If `total` is not specified,
		/// the sum of all points in the wildcard series will be used instead.
		/// <para>
		/// A list of nodes can optionally be provided, if so they will be used to match series with their
		/// corresponding totals following the same logic as :py:func:`groupByNodes &lt;groupByNodes&gt;`.
		/// </para>
		/// <para>
		/// When passing `nodes` the `total` parameter may be a series list or `None`.  If it is `None` then
		/// for each series in `seriesList` the percentage of the sum of series in that group will be returned.
		/// </para>
		/// <para>
		/// When not passing `nodes`, the `total` parameter may be a single series, reference the same number
		/// of series as `seriesList` or be a numeric value.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   # Server01 connections failed and succeeded as a percentage of Server01 connections attempted
		///   &amp;target=asPercent(Server01.connections.{failed,succeeded}, Server01.connections.attempted)
		/// </code>
		/// <para>
		///   # For each server, its connections failed as a percentage of its connections attempted
		///   &amp;target=asPercent(Server*.connections.failed, Server*.connections.attempted)
		/// </para>
		/// <para>
		///   # For each server, its connections failed and succeeded as a percentage of its connections attemped
		///   &amp;target=asPercent(Server*.connections.{failed,succeeded}, Server*.connections.attempted, 0)
		/// </para>
		/// <para>
		///   # apache01.threads.busy as a percentage of 1500
		///   &amp;target=asPercent(apache01.threads.busy,1500)
		/// </para>
		/// <para>
		///   # Server01 cpu stats as a percentage of its total
		///   &amp;target=asPercent(Server01.cpu.*.jiffies)
		/// </para>
		/// <para>
		///   # cpu stats for each server as a percentage of its total
		///   &amp;target=asPercent(Server*.cpu.*.jiffies, None, 0)
		/// </para>
		/// <para>
		/// When using `nodes`, any series or totals that can't be matched will create output series with
		/// names like ``asPercent(someSeries,MISSING)`` or ``asPercent(MISSING,someTotalSeries)`` and all
		/// values set to None. If desired these series can be filtered out by piping the result through
		/// ``|exclude("MISSING")`` as shown below:
		/// </para>
		/// <code>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)
		/// </code>
		/// <para>
		///   # will produce 3 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		///   # asPercent(Server2.memory.used,MISSING) [all values will be None]
		///   # asPercent(MISSING,Server3.memory.total) [all values will be None]
		/// </para>
		/// <para>
		///   &amp;target=asPercent(Server{1,2}.memory.used,Server{1,3}.memory.total,0)|exclude("MISSING")
		/// </para>
		/// <para>
		///   # will produce 1 output series:
		///   # asPercent(Server1.memory.used,Server1.memory.total) [values will be as expected]
		/// </para>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   When `total` is a seriesList, specifying `nodes` to match series with the corresponding total
		///   series will increase reliability.
		/// </para>
		/// </summary>
		public SeriesListFunction Pct()
		{
			return Unary("pct");
		}

		/// <summary>
		/// percentileOfSeries returns a single series which is composed of the n-percentile
		/// values taken across a wildcard series at each point. Unless `interpolate` is
		/// set to True, percentile values are actual values contained in one of the
		/// supplied series.
		/// </summary>
		public SeriesListFunction PercentileOfSeries(int n, bool interpolate = false)
		{
			return Ternary("percentileOfSeries", n, interpolate?1:0);
		}

		/// <summary>
		/// percentileOfSeries returns a single series which is composed of the n-percentile
		/// values taken across a wildcard series at each point. Unless `interpolate` is
		/// set to True, percentile values are actual values contained in one of the
		/// supplied series.
		/// </summary>
		public SeriesListFunction PercentileOfSeries(int n)
		{
			return Binary("percentileOfSeries", n);
		}

		/// <summary>
		/// NonNegativeDerivative adjusted for the series time interval
		/// This is useful for taking a running total metric and showing how many requests
		/// per second were handled.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=perSecond(company.server.application01.ifconfig.TXPackets)
		/// </code>
		/// <para>
		/// Each time you run ifconfig, the RX and TXPackets are higher (assuming there
		/// is network traffic.) By applying the perSecond function, you can get an
		/// idea of the packets per second sent or received, even though you're only
		/// recording the total.
		/// </para>
		/// </summary>
		public SeriesListFunction PerSecond(double? maxValue = null)
		{
			return Binary("perSecond", maxValue?.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// NonNegativeDerivative adjusted for the series time interval
		/// This is useful for taking a running total metric and showing how many requests
		/// per second were handled.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=perSecond(company.server.application01.ifconfig.TXPackets)
		/// </code>
		/// <para>
		/// Each time you run ifconfig, the RX and TXPackets are higher (assuming there
		/// is network traffic.) By applying the perSecond function, you can get an
		/// idea of the packets per second sent or received, even though you're only
		/// recording the total.
		/// </para>
		/// </summary>
		public SeriesListFunction PerSecond()
		{
			return Unary("perSecond");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by a constant, and raises the datapoint
		/// by the power of the constant provided at each point.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=pow(Server.instance01.threads.busy,10)
		///   &amp;target=pow(Server.instance*.threads.busy,10)
		/// </code>
		/// </summary>
		public SeriesListFunction Pow(double factor)
		{
			return Binary("pow", factor.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Takes two or more series and pows their points. A constant line may be
		/// used.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=powSeries(Server.instance01.app.requests, Server.instance01.app.replies)
		/// </code>
		/// </summary>
		public SeriesListFunction PowSeries(params SeriesListBase[] seriesList)
		{
			return Multiple("powSeries", seriesList);
		}

		/// <summary>
		/// Takes a wildcard seriesList.
		/// Distills down a set of inputs into the range of the series
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///     &amp;target=rangeOfSeries(Server*.connections.total)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``rangeOf``.
		/// </para>
		/// </summary>
		public SeriesListFunction RangeOfSeries(params SeriesListBase[] seriesLists)
		{
			return Multiple("rangeOfSeries", seriesLists);
		}

		/// <summary>
		/// Removes data above the nth percentile from the series or list of series provided.
		/// Values above this percentile are assigned a value of None.
		/// </summary>
		public SeriesListFunction RemoveAbovePercentile(int n)
		{
			return Binary("removeAbovePercentile", n);
		}

		/// <summary>
		/// Removes data above the given threshold from the series or list of series provided.
		/// Values above this threshold are assigned a value of None.
		/// </summary>
		public SeriesListFunction RemoveAboveValue(int n)
		{
			return Binary("removeAboveValue", n);
		}

		/// <summary>
		/// Removes data below the nth percentile from the series or list of series provided.
		/// Values below this percentile are assigned a value of None.
		/// </summary>
		public SeriesListFunction RemoveBelowPercentile(int n)
		{
			return Binary("removeBelowPercentile", n);
		}

		/// <summary>
		/// Removes data below the given threshold from the series or list of series provided.
		/// Values below this threshold are assigned a value of None.
		/// </summary>
		public SeriesListFunction RemoveBelowValue(int n)
		{
			return Binary("removeBelowValue", n);
		}

		/// <summary>
		/// Removes series that do not have an value lying in the x-percentile of all the values at a moment
		/// </summary>
		public SeriesListFunction RemoveBetweenPercentile(int n)
		{
			return Binary("removeBetweenPercentile", n);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// Out of all metrics passed, draws only the metrics with not empty data
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=removeEmptySeries(server*.instance*.threads.busy)
		/// </code>
		/// <para>
		/// Draws only live servers with not empty data.
		/// </para>
		/// <para>
		/// `xFilesFactor` follows the same semantics as in Whisper storage schemas.  Setting it to 0 (the
		/// default) means that only a single value in the series needs to be non-null for it to be
		/// considered non-empty, setting it to 1 means that all values in the series must be non-null.
		/// A setting of 0.5 means that at least half the values in the series must be non-null.
		/// </para>
		/// </summary>
		public SeriesListFunction RemoveEmptySeries(double xFilesFactor)
		{
			return Binary("removeEmptySeries", xFilesFactor.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList optionally followed by a precision, and rounds each
		/// datapoint to the specified precision.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=round(Server.instance01.threads.busy)
		///   &amp;target=round(Server.instance01.threads.busy,2)
		/// </code>
		/// </summary>
		public SeriesListFunction Round(int precision = 0)
		{
			return Binary("round", precision);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList optionally followed by a precision, and rounds each
		/// datapoint to the specified precision.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=round(Server.instance01.threads.busy)
		///   &amp;target=round(Server.instance01.threads.busy,2)
		/// </code>
		/// </summary>
		public SeriesListFunction Round()
		{
			return Unary("round");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by a constant, and multiplies the datapoint
		/// by the constant provided at each point.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=scale(Server.instance01.threads.busy,10)
		///   &amp;target=scale(Server.instance*.threads.busy,10)
		/// </code>
		/// </summary>
		public SeriesListFunction Scale(double factor)
		{
			return Binary("scale", factor.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList and returns "value per seconds" where
		/// seconds is a last argument to this functions.
		/// <para>
		/// Useful in conjunction with derivative or integral function if you want
		/// to normalize its result to a known resolution for arbitrary retentions
		/// </para>
		/// </summary>
		public SeriesListFunction ScaleToSeconds(int seconds)
		{
			return Binary("scaleToSeconds", seconds);
		}

		/// <summary>
		/// Graph the series on the secondary Y axis.
		/// </summary>
		public SeriesListFunction SecondYAxis()
		{
			return Unary("secondYAxis");
		}

		/// <summary>
		/// Short form: xFilesFactor()
		/// <para>
		/// Takes one metric or a wildcard seriesList and an xFilesFactor value between 0 and 1
		/// </para>
		/// <para>
		/// When a series needs to be consolidated, this sets the fraction of values in an interval that must
		/// not be null for the consolidation to be considered valid.  If there are not enough values then
		/// None will be returned for that interval.
		/// </para>
		/// <code>
		///   &amp;target=xFilesFactor(Sales.widgets.largeBlue, 0.5)
		///   &amp;target=Servers.web01.sda1.free_space|consolidateBy('max')|xFilesFactor(0.5)
		/// </code>
		/// <para>
		/// The `xFilesFactor` set via this function is used as the default for all functions that accept an
		/// `xFilesFactor` parameter, all functions that aggregate data across multiple series and/or
		/// intervals, and `maxDataPoints &lt;render_api.html#maxdatapoints&gt;`_ consolidation.
		/// </para>
		/// <para>
		/// A default for the entire render request can also be set using the
		/// `xFilesFactor &lt;render_api.html#xfilesfactor&gt;`_ query parameter.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   `xFilesFactor` follows the same semantics as in Whisper storage schemas.  Setting it to 0 (the
		///   default) means that only a single value in a given interval needs to be non-null, setting it to
		///   1 means that all values in the interval must be non-null.  A setting of 0.5 means that at least
		///   half the values in the interval must be non-null.
		/// </para>
		/// </summary>
		public SeriesListFunction SetXFilesFactor(double xFilesFactor)
		{
			return Binary("setXFilesFactor", xFilesFactor.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Smarter version of summarize.
		/// <para>
		/// The alignToFrom boolean parameter has been replaced by alignTo and no longer has any effect.
		/// Alignment can be to years, months, weeks, days, hours, and minutes.
		/// </para>
		/// <para>
		/// This function can be used with aggregation functions ``average``, ``median``, ``sum``, ``min``,
		/// ``max``, ``diff``, ``stddev``, ``count``, ``range``, ``multiply`` &amp; ``last``.
		/// </para>
		/// </summary>
		public SeriesListFunction SmartSummarize(string intervalString, string func = "sum", string alignTo = null)
		{
			return Quaternary("smartSummarize", SingleQuote(intervalString), SingleQuote(func), SingleQuote(alignTo));
		}

		/// <summary>
		/// Smarter version of summarize.
		/// <para>
		/// The alignToFrom boolean parameter has been replaced by alignTo and no longer has any effect.
		/// Alignment can be to years, months, weeks, days, hours, and minutes.
		/// </para>
		/// <para>
		/// This function can be used with aggregation functions ``average``, ``median``, ``sum``, ``min``,
		/// ``max``, ``diff``, ``stddev``, ``count``, ``range``, ``multiply`` &amp; ``last``.
		/// </para>
		/// </summary>
		public SeriesListFunction SmartSummarize(string intervalString, string func = "sum")
		{
			return Ternary("smartSummarize", SingleQuote(intervalString), SingleQuote(func));
		}

		/// <summary>
		/// Smarter version of summarize.
		/// <para>
		/// The alignToFrom boolean parameter has been replaced by alignTo and no longer has any effect.
		/// Alignment can be to years, months, weeks, days, hours, and minutes.
		/// </para>
		/// <para>
		/// This function can be used with aggregation functions ``average``, ``median``, ``sum``, ``min``,
		/// ``max``, ``diff``, ``stddev``, ``count``, ``range``, ``multiply`` &amp; ``last``.
		/// </para>
		/// </summary>
		public SeriesListFunction SmartSummarize(string intervalString)
		{
			return Binary("smartSummarize", SingleQuote(intervalString));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an aggregation function and an
		/// optional ``reverse`` parameter.
		/// <para>
		/// Returns the metrics sorted according to the specified function.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=sortBy(server*.instance*.threads.busy,'max')
		/// </code>
		/// <para>
		/// Draws the servers in ascending order by maximum.
		/// </para>
		/// </summary>
		public SeriesListFunction SortBy(string func = "average", bool reverse = false)
		{
			return Ternary("sortBy", SingleQuote(func), reverse?1:0);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an aggregation function and an
		/// optional ``reverse`` parameter.
		/// <para>
		/// Returns the metrics sorted according to the specified function.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=sortBy(server*.instance*.threads.busy,'max')
		/// </code>
		/// <para>
		/// Draws the servers in ascending order by maximum.
		/// </para>
		/// </summary>
		public SeriesListFunction SortBy(string func = "average")
		{
			return Binary("sortBy", SingleQuote(func));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an aggregation function and an
		/// optional ``reverse`` parameter.
		/// <para>
		/// Returns the metrics sorted according to the specified function.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=sortBy(server*.instance*.threads.busy,'max')
		/// </code>
		/// <para>
		/// Draws the servers in ascending order by maximum.
		/// </para>
		/// </summary>
		public SeriesListFunction SortBy()
		{
			return Unary("sortBy");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// <para>
		/// Sorts the list of metrics in descending order by the maximum value across the time period
		/// specified.  Useful with the &amp;areaMode=all parameter, to keep the
		/// lowest value lines visible.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=sortByMaxima(server*.instance*.memory.free)
		/// </code>
		/// </summary>
		public SeriesListFunction SortByMaxima()
		{
			return Unary("sortByMaxima");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// <para>
		/// Sorts the list of metrics by the lowest value across the time period
		/// specified, including only series that have a maximum value greater than 0.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=sortByMinima(server*.instance*.memory.free)
		/// </code>
		/// </summary>
		public SeriesListFunction SortByMinima()
		{
			return Unary("sortByMinima");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// Sorts the list of metrics by the metric name using either alphabetical order or natural sorting.
		/// Natural sorting allows names containing numbers to be sorted more naturally, e.g:
		/// - Alphabetical sorting: server1, server11, server12, server2
		/// - Natural sorting: server1, server2, server11, server12
		/// </summary>
		public SeriesListFunction SortByName(bool natural = false, bool reverse = false)
		{
			return Ternary("sortByName", natural?1:0, reverse?1:0);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// Sorts the list of metrics by the metric name using either alphabetical order or natural sorting.
		/// Natural sorting allows names containing numbers to be sorted more naturally, e.g:
		/// - Alphabetical sorting: server1, server11, server12, server2
		/// - Natural sorting: server1, server2, server11, server12
		/// </summary>
		public SeriesListFunction SortByName(bool natural = false)
		{
			return Binary("sortByName", natural?1:0);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// Sorts the list of metrics by the metric name using either alphabetical order or natural sorting.
		/// Natural sorting allows names containing numbers to be sorted more naturally, e.g:
		/// - Alphabetical sorting: server1, server11, server12, server2
		/// - Natural sorting: server1, server2, server11, server12
		/// </summary>
		public SeriesListFunction SortByName()
		{
			return Unary("sortByName");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// <para>
		/// Sorts the list of metrics in descending order by the sum of values across the time period
		/// specified.
		/// </para>
		/// </summary>
		public SeriesListFunction SortByTotal()
		{
			return Unary("sortByTotal");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, and computes the square root of each datapoint.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=squareRoot(Server.instance01.threads.busy)
		/// </code>
		/// </summary>
		public SeriesListFunction SquareRoot()
		{
			return Unary("squareRoot");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList and change them so they are
		/// stacked. This is a way of stacking just a couple of metrics without having
		/// to use the stacked area mode (that stacks everything). By means of this a mixed
		/// stacked and non stacked graph can be made
		/// <para>
		/// It can also take an optional argument with a name of the stack, in case there is
		/// more than one, e.g. for input and output metrics.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=stacked(company.server.application01.ifconfig.TXPackets, 'tx')
		/// </code>
		/// </summary>
		public SeriesListFunction Stacked(string stack = null)
		{
			return Binary("stacked", SingleQuote(stack));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList and change them so they are
		/// stacked. This is a way of stacking just a couple of metrics without having
		/// to use the stacked area mode (that stacks everything). By means of this a mixed
		/// stacked and non stacked graph can be made
		/// <para>
		/// It can also take an optional argument with a name of the stack, in case there is
		/// more than one, e.g. for input and output metrics.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=stacked(company.server.application01.ifconfig.TXPackets, 'tx')
		/// </code>
		/// </summary>
		public SeriesListFunction Stacked()
		{
			return Unary("stacked");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList.
		/// Draws the standard deviation of all metrics passed at each time.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=stddevSeries(company.server.*.threads.busy)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``stddev``.
		/// </para>
		/// </summary>
		public SeriesListFunction StddevSeries(params SeriesListBase[] seriesLists)
		{
			return Multiple("stddevSeries", seriesLists);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Draw the Standard Deviation of all metrics passed for the past N datapoints.
		/// If the ratio of null points in the window is greater than windowTolerance,
		/// skip the calculation. The default for windowTolerance is 0.1 (up to 10% of points
		/// in the window can be missing). Note that if this is set to 0.0, it will cause large
		/// gaps in the output anywhere a single point is missing.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=stdev(server*.instance*.threads.busy,30)
		///   &amp;target=stdev(server*.instance*.cpu.system,30,0.0)
		/// </code>
		/// </summary>
		public SeriesListFunction Stdev(int points, double windowTolerance = 0.1)
		{
			return Ternary("stdev", points, windowTolerance.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by an integer N.
		/// Draw the Standard Deviation of all metrics passed for the past N datapoints.
		/// If the ratio of null points in the window is greater than windowTolerance,
		/// skip the calculation. The default for windowTolerance is 0.1 (up to 10% of points
		/// in the window can be missing). Note that if this is set to 0.0, it will cause large
		/// gaps in the output anywhere a single point is missing.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=stdev(server*.instance*.threads.busy,30)
		///   &amp;target=stdev(server*.instance*.cpu.system,30,0.0)
		/// </code>
		/// </summary>
		public SeriesListFunction Stdev(int points)
		{
			return Binary("stdev", points);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by 1 or 2 integers.  Assume that the
		/// metric name is a list or array, with each element separated by dots.  Prints
		/// n - length elements of the array (if only one integer n is passed) or n - m
		/// elements of the array (if two integers n and m are passed).  The list starts
		/// with element 0 and ends with element (length - 1).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=substr(carbon.agents.hostname.avgUpdateTime,2,4)
		/// </code>
		/// <para>
		/// The label would be printed as "hostname.avgUpdateTime".
		/// </para>
		/// </summary>
		public SeriesListFunction Substr(uint start = 0, uint stop = 0)
		{
			return Ternary("substr", start, stop);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by 1 or 2 integers.  Assume that the
		/// metric name is a list or array, with each element separated by dots.  Prints
		/// n - length elements of the array (if only one integer n is passed) or n - m
		/// elements of the array (if two integers n and m are passed).  The list starts
		/// with element 0 and ends with element (length - 1).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=substr(carbon.agents.hostname.avgUpdateTime,2,4)
		/// </code>
		/// <para>
		/// The label would be printed as "hostname.avgUpdateTime".
		/// </para>
		/// </summary>
		public SeriesListFunction Substr(uint start = 0)
		{
			return Binary("substr", start);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList followed by 1 or 2 integers.  Assume that the
		/// metric name is a list or array, with each element separated by dots.  Prints
		/// n - length elements of the array (if only one integer n is passed) or n - m
		/// elements of the array (if two integers n and m are passed).  The list starts
		/// with element 0 and ends with element (length - 1).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=substr(carbon.agents.hostname.avgUpdateTime,2,4)
		/// </code>
		/// <para>
		/// The label would be printed as "hostname.avgUpdateTime".
		/// </para>
		/// </summary>
		public SeriesListFunction Substr()
		{
			return Unary("substr");
		}

		/// <summary>
		/// Short form: sum()
		/// <para>
		/// This will add metrics together and return the sum at each datapoint. (See
		/// integral for a sum over time)
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=sum(company.server.application*.requestsHandled)
		/// </code>
		/// <para>
		/// This would show the sum of all requests handled per minute (provided
		/// requestsHandled are collected once a minute).   If metrics with different
		/// retention rates are combined, the coarsest metric is graphed, and the sum
		/// of the other metrics is averaged for the metrics with finer retention rates.
		/// </para>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``sum``.
		/// </para>
		/// </summary>
		public SeriesListFunction Sum(params SeriesListBase[] seriesLists)
		{
			return Multiple("sum", seriesLists);
		}

		/// <summary>
		/// Summarize the data into interval buckets of a certain size.
		/// <para>
		/// By default, the contents of each interval bucket are summed together. This is
		/// useful for counters where each increment represents a discrete event and
		/// retrieving a "per X" value requires summing all the events in that interval.
		/// </para>
		/// <para>
		/// Specifying 'average' instead will return the mean for each bucket, which can be more
		/// useful when the value is a gauge that represents a certain value in time.
		/// </para>
		/// <para>
		/// This function can be used with aggregation functions ``average``, ``median``, ``sum``, ``min``,
		/// ``max``, ``diff``, ``stddev``, ``count``, ``range``, ``multiply`` &amp; ``last``.
		/// </para>
		/// <para>
		/// By default, buckets are calculated by rounding to the nearest interval. This
		/// works well for intervals smaller than a day. For example, 22:32 will end up
		/// in the bucket 22:00-23:00 when the interval=1hour.
		/// </para>
		/// <para>
		/// Passing alignToFrom=true will instead create buckets starting at the from
		/// time. In this case, the bucket for 22:32 depends on the from time. If
		/// from=6:30 then the 1hour bucket for 22:32 is 22:30-23:30.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=summarize(counter.errors, "1hour") # total errors per hour
		///   &amp;target=summarize(nonNegativeDerivative(gauge.num_users), "1week") # new users per week
		///   &amp;target=summarize(queue.size, "1hour", "avg") # average queue size per hour
		///   &amp;target=summarize(queue.size, "1hour", "max") # maximum queue size during each hour
		///   &amp;target=summarize(metric, "13week", "avg", true)&amp;from=midnight+20100101 # 2010 Q1-4
		/// </code>
		/// </summary>
		public SeriesListFunction Summarize(string intervalString, string func = "sum", bool alignToFrom = false)
		{
			return Quaternary("summarize", SingleQuote(intervalString), SingleQuote(func), alignToFrom?1:0);
		}

		/// <summary>
		/// Summarize the data into interval buckets of a certain size.
		/// <para>
		/// By default, the contents of each interval bucket are summed together. This is
		/// useful for counters where each increment represents a discrete event and
		/// retrieving a "per X" value requires summing all the events in that interval.
		/// </para>
		/// <para>
		/// Specifying 'average' instead will return the mean for each bucket, which can be more
		/// useful when the value is a gauge that represents a certain value in time.
		/// </para>
		/// <para>
		/// This function can be used with aggregation functions ``average``, ``median``, ``sum``, ``min``,
		/// ``max``, ``diff``, ``stddev``, ``count``, ``range``, ``multiply`` &amp; ``last``.
		/// </para>
		/// <para>
		/// By default, buckets are calculated by rounding to the nearest interval. This
		/// works well for intervals smaller than a day. For example, 22:32 will end up
		/// in the bucket 22:00-23:00 when the interval=1hour.
		/// </para>
		/// <para>
		/// Passing alignToFrom=true will instead create buckets starting at the from
		/// time. In this case, the bucket for 22:32 depends on the from time. If
		/// from=6:30 then the 1hour bucket for 22:32 is 22:30-23:30.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=summarize(counter.errors, "1hour") # total errors per hour
		///   &amp;target=summarize(nonNegativeDerivative(gauge.num_users), "1week") # new users per week
		///   &amp;target=summarize(queue.size, "1hour", "avg") # average queue size per hour
		///   &amp;target=summarize(queue.size, "1hour", "max") # maximum queue size during each hour
		///   &amp;target=summarize(metric, "13week", "avg", true)&amp;from=midnight+20100101 # 2010 Q1-4
		/// </code>
		/// </summary>
		public SeriesListFunction Summarize(string intervalString, string func = "sum")
		{
			return Ternary("summarize", SingleQuote(intervalString), SingleQuote(func));
		}

		/// <summary>
		/// Summarize the data into interval buckets of a certain size.
		/// <para>
		/// By default, the contents of each interval bucket are summed together. This is
		/// useful for counters where each increment represents a discrete event and
		/// retrieving a "per X" value requires summing all the events in that interval.
		/// </para>
		/// <para>
		/// Specifying 'average' instead will return the mean for each bucket, which can be more
		/// useful when the value is a gauge that represents a certain value in time.
		/// </para>
		/// <para>
		/// This function can be used with aggregation functions ``average``, ``median``, ``sum``, ``min``,
		/// ``max``, ``diff``, ``stddev``, ``count``, ``range``, ``multiply`` &amp; ``last``.
		/// </para>
		/// <para>
		/// By default, buckets are calculated by rounding to the nearest interval. This
		/// works well for intervals smaller than a day. For example, 22:32 will end up
		/// in the bucket 22:00-23:00 when the interval=1hour.
		/// </para>
		/// <para>
		/// Passing alignToFrom=true will instead create buckets starting at the from
		/// time. In this case, the bucket for 22:32 depends on the from time. If
		/// from=6:30 then the 1hour bucket for 22:32 is 22:30-23:30.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=summarize(counter.errors, "1hour") # total errors per hour
		///   &amp;target=summarize(nonNegativeDerivative(gauge.num_users), "1week") # new users per week
		///   &amp;target=summarize(queue.size, "1hour", "avg") # average queue size per hour
		///   &amp;target=summarize(queue.size, "1hour", "max") # maximum queue size during each hour
		///   &amp;target=summarize(metric, "13week", "avg", true)&amp;from=midnight+20100101 # 2010 Q1-4
		/// </code>
		/// </summary>
		public SeriesListFunction Summarize(string intervalString)
		{
			return Binary("summarize", SingleQuote(intervalString));
		}

		/// <summary>
		/// Short form: sum()
		/// <para>
		/// This will add metrics together and return the sum at each datapoint. (See
		/// integral for a sum over time)
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=sum(company.server.application*.requestsHandled)
		/// </code>
		/// <para>
		/// This would show the sum of all requests handled per minute (provided
		/// requestsHandled are collected once a minute).   If metrics with different
		/// retention rates are combined, the coarsest metric is graphed, and the sum
		/// of the other metrics is averaged for the metrics with finer retention rates.
		/// </para>
		/// <para>
		/// This is an alias for :py:func:`aggregate &lt;aggregate&gt;` with aggregation ``sum``.
		/// </para>
		/// </summary>
		public SeriesListFunction SumSeries(params SeriesListBase[] seriesLists)
		{
			return Multiple("sumSeries", seriesLists);
		}

		/// <summary>
		/// Call sumSeries after inserting wildcards at the given position(s).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=sumSeriesWithWildcards(host.cpu-[0-7].cpu-{user,system}.value, 1)
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=sumSeries(host.cpu-[0-7].cpu-user.value)&amp;target=sumSeries(host.cpu-[0-7].cpu-system.value)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregateWithWildcards &lt;aggregateWithWildcards&gt;` with aggregation ``sum``.
		/// </para>
		/// </summary>
		public SeriesListFunction SumSeriesWithWildcards(params uint[] position)
		{
			return new SeriesListFunction("sumSeriesWithWildcards", Merge(this, position));
		}

		/// <summary>
		/// Call sumSeries after inserting wildcards at the given position(s).
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=sumSeriesWithWildcards(host.cpu-[0-7].cpu-{user,system}.value, 1)
		/// </code>
		/// <para>
		/// This would be the equivalent of
		/// </para>
		/// <code>
		///   &amp;target=sumSeries(host.cpu-[0-7].cpu-user.value)&amp;target=sumSeries(host.cpu-[0-7].cpu-system.value)
		/// </code>
		/// <para>
		/// This is an alias for :py:func:`aggregateWithWildcards &lt;aggregateWithWildcards&gt;` with aggregation ``sum``.
		/// </para>
		/// </summary>
		public SeriesListFunction SumSeriesWithWildcards()
		{
			return Unary("sumSeriesWithWildcards");
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// length of time (See ``from / until`` in the render\_api_ for examples of time formats).
		/// <para>
		/// Draws the selected metrics shifted in time. If no sign is given, a minus sign ( - ) is
		/// implied which will shift the metric back in time. If a plus sign ( + ) is given, the
		/// metric will be shifted forward in time.
		/// </para>
		/// <para>
		/// Will reset the end date range automatically to the end of the base stat unless
		/// resetEnd is False. Example case is when you timeshift to last week and have the graph
		/// date range set to include a time in the future, will limit this timeshift to pretend
		/// ending at the current time. If resetEnd is False, will instead draw full range including
		/// future time.
		/// </para>
		/// <para>
		/// Because time is shifted by a fixed number of seconds, comparing a time period with DST to
		/// a time period without DST, and vice-versa, will result in an apparent misalignment. For
		/// example, 8am might be overlaid with 7am. To compensate for this, use the alignDST option.
		/// </para>
		/// <para>
		/// Useful for comparing a metric against itself at a past periods or correcting data
		/// stored at an offset.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=timeShift(Sales.widgets.largeBlue,"7d")
		///   &amp;target=timeShift(Sales.widgets.largeBlue,"-7d")
		///   &amp;target=timeShift(Sales.widgets.largeBlue,"+1h")
		/// </code>
		/// </summary>
		public SeriesListFunction TimeShift(string timeShift, bool resetEnd = true, bool alignDst = false)
		{
			return Quaternary("timeShift", SingleQuote(timeShift), resetEnd?1:0, alignDst?1:0);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// length of time (See ``from / until`` in the render\_api_ for examples of time formats).
		/// <para>
		/// Draws the selected metrics shifted in time. If no sign is given, a minus sign ( - ) is
		/// implied which will shift the metric back in time. If a plus sign ( + ) is given, the
		/// metric will be shifted forward in time.
		/// </para>
		/// <para>
		/// Will reset the end date range automatically to the end of the base stat unless
		/// resetEnd is False. Example case is when you timeshift to last week and have the graph
		/// date range set to include a time in the future, will limit this timeshift to pretend
		/// ending at the current time. If resetEnd is False, will instead draw full range including
		/// future time.
		/// </para>
		/// <para>
		/// Because time is shifted by a fixed number of seconds, comparing a time period with DST to
		/// a time period without DST, and vice-versa, will result in an apparent misalignment. For
		/// example, 8am might be overlaid with 7am. To compensate for this, use the alignDST option.
		/// </para>
		/// <para>
		/// Useful for comparing a metric against itself at a past periods or correcting data
		/// stored at an offset.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=timeShift(Sales.widgets.largeBlue,"7d")
		///   &amp;target=timeShift(Sales.widgets.largeBlue,"-7d")
		///   &amp;target=timeShift(Sales.widgets.largeBlue,"+1h")
		/// </code>
		/// </summary>
		public SeriesListFunction TimeShift(string timeShift, bool resetEnd = true)
		{
			return Ternary("timeShift", SingleQuote(timeShift), resetEnd?1:0);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// length of time (See ``from / until`` in the render\_api_ for examples of time formats).
		/// <para>
		/// Draws the selected metrics shifted in time. If no sign is given, a minus sign ( - ) is
		/// implied which will shift the metric back in time. If a plus sign ( + ) is given, the
		/// metric will be shifted forward in time.
		/// </para>
		/// <para>
		/// Will reset the end date range automatically to the end of the base stat unless
		/// resetEnd is False. Example case is when you timeshift to last week and have the graph
		/// date range set to include a time in the future, will limit this timeshift to pretend
		/// ending at the current time. If resetEnd is False, will instead draw full range including
		/// future time.
		/// </para>
		/// <para>
		/// Because time is shifted by a fixed number of seconds, comparing a time period with DST to
		/// a time period without DST, and vice-versa, will result in an apparent misalignment. For
		/// example, 8am might be overlaid with 7am. To compensate for this, use the alignDST option.
		/// </para>
		/// <para>
		/// Useful for comparing a metric against itself at a past periods or correcting data
		/// stored at an offset.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=timeShift(Sales.widgets.largeBlue,"7d")
		///   &amp;target=timeShift(Sales.widgets.largeBlue,"-7d")
		///   &amp;target=timeShift(Sales.widgets.largeBlue,"+1h")
		/// </code>
		/// </summary>
		public SeriesListFunction TimeShift(string timeShift)
		{
			return Binary("timeShift", SingleQuote(timeShift));
		}

		/// <summary>
		/// Takes one metric or a wildcard metric, followed by a quoted string with the
		/// time to start the line and another quoted string with the time to end the line.
		/// The start and end times are inclusive. See ``from / until`` in the render\_api_
		/// for examples of time formats.
		/// <para>
		/// Useful for filtering out a part of a series of data from a wider range of
		/// data.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=timeSlice(network.core.port1,"00:00 20140101","11:59 20140630")
		///   &amp;target=timeSlice(network.core.port1,"12:00 20140630","now")
		/// </code>
		/// </summary>
		public SeriesListFunction TimeSlice(string startSliceAt, string endSliceAt = "now")
		{
			return Ternary("timeSlice", SingleQuote(startSliceAt), SingleQuote(endSliceAt));
		}

		/// <summary>
		/// Takes one metric or a wildcard metric, followed by a quoted string with the
		/// time to start the line and another quoted string with the time to end the line.
		/// The start and end times are inclusive. See ``from / until`` in the render\_api_
		/// for examples of time formats.
		/// <para>
		/// Useful for filtering out a part of a series of data from a wider range of
		/// data.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=timeSlice(network.core.port1,"00:00 20140101","11:59 20140630")
		///   &amp;target=timeSlice(network.core.port1,"12:00 20140630","now")
		/// </code>
		/// </summary>
		public SeriesListFunction TimeSlice(string startSliceAt)
		{
			return Binary("timeSlice", SingleQuote(startSliceAt));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// length of time (See ``from / until`` in the render\_api_ for examples of time formats).
		/// Also takes a start multiplier and end multiplier for the length of time
		/// <para>
		/// create a seriesList which is composed the original metric series stacked with time shifts
		/// starting time shifts from the start multiplier through the end multiplier
		/// </para>
		/// <para>
		/// Useful for looking at history, or feeding into averageSeries or stddevSeries.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=timeStack(Sales.widgets.largeBlue,"1d",0,7)    # create a series for today and each of the previous 7 days
		/// </code>
		/// </summary>
		public SeriesListFunction TimeStack(string timeShiftUnit = "1d", int timeShiftStart = 0, int timeShiftEnd = 7)
		{
			return Quaternary("timeStack", SingleQuote(timeShiftUnit), timeShiftStart, timeShiftEnd);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// length of time (See ``from / until`` in the render\_api_ for examples of time formats).
		/// Also takes a start multiplier and end multiplier for the length of time
		/// <para>
		/// create a seriesList which is composed the original metric series stacked with time shifts
		/// starting time shifts from the start multiplier through the end multiplier
		/// </para>
		/// <para>
		/// Useful for looking at history, or feeding into averageSeries or stddevSeries.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=timeStack(Sales.widgets.largeBlue,"1d",0,7)    # create a series for today and each of the previous 7 days
		/// </code>
		/// </summary>
		public SeriesListFunction TimeStack(string timeShiftUnit = "1d", int timeShiftStart = 0)
		{
			return Ternary("timeStack", SingleQuote(timeShiftUnit), timeShiftStart);
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// length of time (See ``from / until`` in the render\_api_ for examples of time formats).
		/// Also takes a start multiplier and end multiplier for the length of time
		/// <para>
		/// create a seriesList which is composed the original metric series stacked with time shifts
		/// starting time shifts from the start multiplier through the end multiplier
		/// </para>
		/// <para>
		/// Useful for looking at history, or feeding into averageSeries or stddevSeries.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=timeStack(Sales.widgets.largeBlue,"1d",0,7)    # create a series for today and each of the previous 7 days
		/// </code>
		/// </summary>
		public SeriesListFunction TimeStack(string timeShiftUnit = "1d")
		{
			return Binary("timeStack", SingleQuote(timeShiftUnit));
		}

		/// <summary>
		/// Takes one metric or a wildcard seriesList, followed by a quoted string with the
		/// length of time (See ``from / until`` in the render\_api_ for examples of time formats).
		/// Also takes a start multiplier and end multiplier for the length of time
		/// <para>
		/// create a seriesList which is composed the original metric series stacked with time shifts
		/// starting time shifts from the start multiplier through the end multiplier
		/// </para>
		/// <para>
		/// Useful for looking at history, or feeding into averageSeries or stddevSeries.
		/// </para>
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=timeStack(Sales.widgets.largeBlue,"1d",0,7)    # create a series for today and each of the previous 7 days
		/// </code>
		/// </summary>
		public SeriesListFunction TimeStack()
		{
			return Unary("timeStack");
		}

		/// <summary>
		/// Takes a metric or wildcard seriesList and replaces null values with the value
		/// specified by `default`.  The value 0 used if not specified.  The optional
		/// referenceSeries, if specified, is a metric or wildcard series list that governs
		/// which time intervals nulls should be replaced.  If specified, nulls are replaced
		/// only in intervals where a non-null is found for the same interval in any of
		/// referenceSeries.  This method compliments the drawNullAsZero function in
		/// graphical mode, but also works in text-only mode.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=transformNull(webapp.pages.*.views,-1)
		/// </code>
		/// <para>
		/// This would take any page that didn't have values and supply negative 1 as a default.
		/// Any other numeric value may be used as well.
		/// </para>
		/// </summary>
		public SeriesListFunction TransformNull(double @default = 0, SeriesListBase referenceSeries = null)
		{
			return Ternary("transformNull", @default.ToString("r", CultureInfo.InvariantCulture), referenceSeries);
		}

		/// <summary>
		/// Takes a metric or wildcard seriesList and replaces null values with the value
		/// specified by `default`.  The value 0 used if not specified.  The optional
		/// referenceSeries, if specified, is a metric or wildcard series list that governs
		/// which time intervals nulls should be replaced.  If specified, nulls are replaced
		/// only in intervals where a non-null is found for the same interval in any of
		/// referenceSeries.  This method compliments the drawNullAsZero function in
		/// graphical mode, but also works in text-only mode.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=transformNull(webapp.pages.*.views,-1)
		/// </code>
		/// <para>
		/// This would take any page that didn't have values and supply negative 1 as a default.
		/// Any other numeric value may be used as well.
		/// </para>
		/// </summary>
		public SeriesListFunction TransformNull(double @default = 0)
		{
			return Binary("transformNull", @default.ToString("r", CultureInfo.InvariantCulture));
		}

		/// <summary>
		/// Takes a metric or wildcard seriesList and replaces null values with the value
		/// specified by `default`.  The value 0 used if not specified.  The optional
		/// referenceSeries, if specified, is a metric or wildcard series list that governs
		/// which time intervals nulls should be replaced.  If specified, nulls are replaced
		/// only in intervals where a non-null is found for the same interval in any of
		/// referenceSeries.  This method compliments the drawNullAsZero function in
		/// graphical mode, but also works in text-only mode.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=transformNull(webapp.pages.*.views,-1)
		/// </code>
		/// <para>
		/// This would take any page that didn't have values and supply negative 1 as a default.
		/// Any other numeric value may be used as well.
		/// </para>
		/// </summary>
		public SeriesListFunction TransformNull()
		{
			return Unary("transformNull");
		}

		/// <summary>
		/// Takes an arbitrary number of seriesLists and returns unique series, filtered by name.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=unique(mostDeviant(server.*.disk_free,5),lowestCurrent(server.*.disk_free,5))
		/// </code>
		/// <para>
		/// Draws servers with low disk space, and servers with highly deviant disk space, but never the same series twice.
		/// </para>
		/// </summary>
		public SeriesListFunction Unique(params SeriesListBase[] seriesLists)
		{
			return Multiple("unique", seriesLists);
		}

		/// <summary>
		/// Compares the maximum of each series against the given `value`. If the series
		/// maximum is greater than `value`, the regular expression search and replace is
		/// applied against the series name to plot a related metric
		/// <para>
		/// e.g. given useSeriesAbove(ganglia.metric1.reqs,10,'reqs','time'),
		/// the response time metric will be plotted only when the maximum value of the
		/// corresponding request/s metric is &gt; 10
		/// </para>
		/// <code>
		///   &amp;target=useSeriesAbove(ganglia.metric1.reqs,10,"reqs","time")
		/// </code>
		/// </summary>
		public SeriesListFunction UseSeriesAbove(string value, string search, string replace)
		{
			return Quaternary("useSeriesAbove", SingleQuote(value), SingleQuote(search), SingleQuote(replace));
		}

		/// <summary>
		/// Takes a series of average values and a series of weights and
		/// produces a weighted average for all values.
		/// The corresponding values should share one or more zero-indexed nodes and/or tags.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=weightedAverage(*.transactions.mean,*.transactions.count,0)
		/// </code>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// </summary>
		public SeriesListFunction WeightedAverage(SeriesListBase seriesListWeight, params uint[] nodes)
		{
			return new SeriesListFunction("weightedAverage", Merge(this, Merge(seriesListWeight, nodes)));
		}

		/// <summary>
		/// Takes a series of average values and a series of weights and
		/// produces a weighted average for all values.
		/// The corresponding values should share one or more zero-indexed nodes and/or tags.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=weightedAverage(*.transactions.mean,*.transactions.count,0)
		/// </code>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// </summary>
		public SeriesListFunction WeightedAverage(SeriesListBase seriesListWeight, params string[] nodes)
		{
			return new SeriesListFunction("weightedAverage", Merge(this, Merge(seriesListWeight, nodes.Select(SingleQuote).ToArray())));
		}

		/// <summary>
		/// Takes a series of average values and a series of weights and
		/// produces a weighted average for all values.
		/// The corresponding values should share one or more zero-indexed nodes and/or tags.
		/// <para>
		/// Example:
		/// </para>
		/// <code>
		///   &amp;target=weightedAverage(*.transactions.mean,*.transactions.count,0)
		/// </code>
		/// <para>
		/// Each node may be an integer referencing a node in the series name or a string identifying a tag.
		/// </para>
		/// </summary>
		public SeriesListFunction WeightedAverage(SeriesListBase seriesListWeight)
		{
			return Binary("weightedAverage", seriesListWeight);
		}

		/// <summary>
		/// Short form: xFilesFactor()
		/// <para>
		/// Takes one metric or a wildcard seriesList and an xFilesFactor value between 0 and 1
		/// </para>
		/// <para>
		/// When a series needs to be consolidated, this sets the fraction of values in an interval that must
		/// not be null for the consolidation to be considered valid.  If there are not enough values then
		/// None will be returned for that interval.
		/// </para>
		/// <code>
		///   &amp;target=xFilesFactor(Sales.widgets.largeBlue, 0.5)
		///   &amp;target=Servers.web01.sda1.free_space|consolidateBy('max')|xFilesFactor(0.5)
		/// </code>
		/// <para>
		/// The `xFilesFactor` set via this function is used as the default for all functions that accept an
		/// `xFilesFactor` parameter, all functions that aggregate data across multiple series and/or
		/// intervals, and `maxDataPoints &lt;render_api.html#maxdatapoints&gt;`_ consolidation.
		/// </para>
		/// <para>
		/// A default for the entire render request can also be set using the
		/// `xFilesFactor &lt;render_api.html#xfilesfactor&gt;`_ query parameter.
		/// </para>
		/// <para>
		/// .. note::
		/// </para>
		/// <para>
		///   `xFilesFactor` follows the same semantics as in Whisper storage schemas.  Setting it to 0 (the
		///   default) means that only a single value in a given interval needs to be non-null, setting it to
		///   1 means that all values in the interval must be non-null.  A setting of 0.5 means that at least
		///   half the values in the interval must be non-null.
		/// </para>
		/// </summary>
		public SeriesListFunction XFilesFactor(double xFilesFactor)
		{
			return Binary("xFilesFactor", xFilesFactor.ToString("r", CultureInfo.InvariantCulture));
		}
	}
}
