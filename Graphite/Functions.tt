<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="Newtonsoft.Json" #>
<#@ output extension=".cs" #>
<#@ import namespace="Newtonsoft.Json.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Xml" #>
<#
var content = File.ReadAllText(Host.ResolvePath("functions.json"));
var json = JObject.Parse(content);
var functions = new List<JFunction>();
foreach(var entry in json)
{
	functions.Add(new JFunction(entry.Value));
}
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ahd.Graphite.Base;
using System;
using System.Globalization;
using System.Linq;

namespace ahd.Graphite.Base
{
#pragma warning disable CS0419 // Ambiguous reference in cref attribute
	public abstract partial class SeriesListBase
	{
<#
bool first = true;
foreach (var function in functions.Where(x=>x.IsWrapping).SelectMany(OptionalOverloads).SelectMany(Overloads).OrderBy(x=>x.Name))
{
	if (!first) Write(Environment.NewLine);
	first = false;
#>
		/// <summary>
<#
foreach(var line in function.GetSummary())
{#>
		/// <#= line #>
<#}#>
		/// </summary>
		public SeriesListFunction <#= function.Name #>(<#= function.GetParameter() #>)
		{
			<#= function.GetBody() #>
		}
<# } #>
	}
}
namespace ahd.Graphite.Functions
{
<#
first = true;
foreach (var function in functions.Where(x=>!x.IsWrapping).OrderBy(x=>x.Name))
{
	if (!first) Write(Environment.NewLine);
#>
	/// <summary>
<#
foreach(var line in function.GetSummary())
{#>
	/// <#= line #>
<#}#>
	/// </summary>
	public partial class <#= function.Name #>SeriesList : SeriesListFunction
	{
<#
first = true;
foreach(var overload in OptionalOverloads(function).SelectMany(Overloads))
{
	if (!first) Write(Environment.NewLine);
	first = false;
#>
		/// <summary>
<#
foreach(var line in overload.GetSummary())
{#>
		/// <#= line #>
<#}#>
		/// </summary>
		public <#= overload.Name #>SeriesList(<#= overload.GetParameter() #>)
			: base("<#= overload.GraphiteName #>"<#= overload.GetBody() #>)
		{
		}
<# } #>
	}
<# } #>
#pragma warning restore CS0419 // Ambiguous reference in cref attribute
}
<#+
private static IEnumerable<JFunction> OptionalOverloads(JFunction function)
{
	yield return function;
	var node = function.Token.DeepClone();
    while(function.Parameter.Count > 1 && !function.Parameter[function.Parameter.Count -1].Required)
    {
		var parameters = (JArray)node["params"];
		parameters.RemoveAt(parameters.Count-1);
		function = new JFunction(node);
		yield return function;
		node = node.DeepClone();
	}
	if (function.Parameter.Count == 1 && function.Parameter[function.Parameter.Count -1].Multiple)
    {
		var parameters = (JArray)node["params"];
		var parameter = parameters[0];
		var multiple = parameter["multiple"];
		multiple.Parent.Remove();
		yield return new JFunction(node);
	}
}
private static IEnumerable<JFunction> Overloads(JFunction function)
{
	if (function.Parameter.Any(x=>x.Type == "nodeOrTag"))
	{
		var node = function.Token.DeepClone();
		var parameters = (JArray)node["params"];
		foreach(var parameter in parameters)
		{
			ReplaceType(parameter, "nodeOrTag", "node");
		}
		yield return new JFunction(node);
		node = function.Token;
		parameters = (JArray)node["params"];
		foreach(var parameter in parameters)
		{
			ReplaceType(parameter, "nodeOrTag", "tag");
		}
		yield return new JFunction(node);
	}
	else if (function.Parameter.Any(x=>x.Type == "intOrInterval"))
	{
		var node = function.Token.DeepClone();
		var parameters = (JArray)node["params"];
		foreach(var parameter in parameters)
		{
			ReplaceType(parameter, "intOrInterval", "integer");
		}
		yield return new JFunction(node);
		node = function.Token;
		parameters = (JArray)node["params"];
		foreach(var parameter in parameters)
		{
			ReplaceType(parameter, "intOrInterval", "interval");
		}
		yield return new JFunction(node);
	}
	else
    {
		yield return function;
    }
}
private static void ReplaceType(JToken token, string from, string to)
{
	if (token["type"] is JValue value)
    {
		if (value.Value.Equals(from))
        {
			value.Value = to;
        }
	}
}
class JFunction
{
	private readonly JToken _jtoken;
	private static readonly Regex _pyFuncRegex = new Regex(":py:func:`([a-zA-Z]+)( &lt;([a-zA-Z]+)&gt;)?`");

	public JFunction(JToken function)
	{
		_jtoken = function;
		GraphiteName = _jtoken["name"]?.ToString();
		Name = GraphiteName.First().ToString().ToUpper() + GraphiteName.Substring(1);
		Description = _jtoken["description"]?.ToString();
		LoadParameter();
    }

	private void LoadParameter()
	{
		var parameters = _jtoken["params"] as JArray;
		if (parameters is null || parameters.Count == 0)
        {
			Parameter = new List<JParameter>();
		}
		else
		{
			Parameter = parameters.Select(x=>new JParameter(x)).ToList();
			var first = Parameter[0];
			if (first.Type == "seriesList")
            {
				if (first.Multiple)
                {
					WrapsMultipleSeries = true;
				}
				else
                {
					WrapsSingleSeries = true;
				}
			}
        }
    }

	public JToken Token => _jtoken;

	public string GraphiteName { get; }
	
	public string Name { get; }

	public string Description { get; set; }

	public List<JParameter> Parameter { get; private set; }

	public bool WrapsSingleSeries { get; set; }

	public bool WrapsMultipleSeries { get; set; }

	public bool IsWrapping => (WrapsMultipleSeries && Parameter.Count == 1) || WrapsSingleSeries;

	public int ParameterCount
    {
		get
		{
			if (Parameter.Any(x=>x.Multiple)) return Int32.MaxValue;
			return Parameter.Count;
		}
	}

	public IEnumerable<string> GetSummary()
    {
		var summary = Description;
		var lines = summary.Split('\n');
		int i = 0;
		for (; i < lines.Length; i++)
		{
			var line = lines[i];
			if (String.IsNullOrEmpty(line)) break;
			yield return XmlEscape(line);
		}
		bool para = false;
		bool wasEmpty = false;
		bool code = false;
		for (; i < lines.Length; i++)
        {
			var line = lines[i];
			if (line == ".. code-block:: none" || line == ".. code-block :: none")
			{
				yield return "<code>";
				code = true;
				para = false;
				wasEmpty = true;
				continue;
			}
			if (string.IsNullOrEmpty(line))
			{
				if (wasEmpty) continue;
				if (code)
				{
					yield return "</code>";
					code = false;
					continue;
				}
				if (para)
				{
					yield return "</para>";
					para = false;
					continue;
				}
				wasEmpty = true;
				continue;
			}
			if (!para && !code)
            {
				yield return "<para>";
				para = true;
			}
			wasEmpty = false;
			line = XmlEscape(line);
			line = _pyFuncRegex.Replace(line, x => {
				var value = x.Groups[3].Value;
				if (String.IsNullOrEmpty(value))
					value = x.Groups[1].Value;
				return $"<see cref=\"SeriesListBase.{Char.ToUpper(value[0])}{value.Substring(1)}\"/>";
			});
			yield return line;
		}
		if (para)
		{
			yield return "</para>";
		}
		if (code)
		{
			yield return "</code>";
		}
	}

	public string GetParameter()
    {
		if (WrapsMultipleSeries && Parameter.Count == 1)
        {
			return $"params SeriesListBase[] {Parameter[0].Name}";
		}
		else if (WrapsSingleSeries)
        {
			if (Parameter.Count == 1)
            {
				return string.Empty;
			}
			else
			{
				var parameters = new List<string>();
                for (int i = 1; i < Parameter.Count; i++)
                {
					parameters.Add(Parameter[i].GetParameter());
                }
				return string.Join(", ", parameters);
			}
		}
		else
		{
			var parameters = new List<string>();
            for (int i = 0; i < Parameter.Count; i++)
            {
				parameters.Add(Parameter[i].GetParameter());
            }
			return string.Join(", ", parameters);
		}
    }

	public string GetBody()
	{
		if (WrapsMultipleSeries && Parameter.Count == 1)
        {
				return $"return Multiple(\"{GraphiteName}\", {Parameter[0].Name});";
		}
		else if (WrapsSingleSeries)
        {
			if (ParameterCount == 1)
            {
				return $"return Unary(\"{GraphiteName}\");";
			}
			else if (ParameterCount == 2)
			{
				return $"return Binary(\"{GraphiteName}\", {Parameter[1].GetBody()});";
			}
			else if (ParameterCount == 3)
			{
				return $"return Ternary(\"{GraphiteName}\", {Parameter[1].GetBody()}, {Parameter[2].GetBody()});";
			}
			else if (ParameterCount == 4)
			{
				return $"return Quaternary(\"{GraphiteName}\", {Parameter[1].GetBody()}, {Parameter[2].GetBody()}, {Parameter[3].GetBody()});";
			}
			else
            {
				var parameters = new StringBuilder();
                for (int i = Parameter.Count - 1; i > 0 ; i--)
                {
					if (parameters.Length == 0)
						parameters.Append(Parameter[i].GetBody());
					else
					{
						parameters.Insert(0, ", ").Insert(0, Parameter[i].GetBody()).Insert(0, "Merge(").Append(')');
					}
                }
				parameters.Insert(0, "Merge(this, ").Append(')');
				return $"return new SeriesListFunction(\"{GraphiteName}\", {parameters});";
			}
		}
		else
        {
			if (Parameter.Count == 0) return String.Empty;
			if (ParameterCount == Int32.MaxValue && Parameter.Count > 1)
			{
				var parameters = new StringBuilder();
				for (int i = Parameter.Count - 1; i > 0 ; i--)
				{
					if (parameters.Length == 0)
						parameters.Append(Parameter[i].GetBody());
					else
					{
						parameters.Insert(0, ", ").Insert(0, Parameter[i].GetBody()).Insert(0, "Merge(").Append(')');
					}
				}
				parameters.Insert(0, ", ");
				return parameters.ToString();
            }
			else
			{
				var parameters = new List<string>();
				for (int i = 0; i < Parameter.Count; i++)
				{
					parameters.Add(Parameter[i].GetBody());
				}
				return ", " + string.Join(", ", parameters);
            }
		}
	}

	private static string XmlEscape(string unescaped)
	{
		XmlDocument doc = new XmlDocument();
		XmlNode node = doc.CreateElement("root");
		node.InnerText = unescaped;
		return node.InnerXml;
	}
}
class JParameter
{
	private readonly JToken _parameter;

	public JParameter(JToken parameter)
	{
		_parameter = parameter;
		Name = _parameter["name"]?.ToString();
		switch(Name)
        {
			case "base":
			case "default":
			case "operator":
                Name = '@' + Name;
				break;
		}
	}

	public string Name { get; }

	public string Type => _parameter["type"]?.ToString();
	
	public string Default => ((JValue)_parameter["default"])?.ToString(CultureInfo.InvariantCulture);
	
	public bool HasDefault => !string.IsNullOrEmpty(Default);
	
	public bool Required => _parameter["required"]?.ToString() == "True";
	
	public bool Multiple => _parameter["multiple"]?.ToString() == "True";

	public string GetParameter()
    {
		var result = new StringBuilder();
		bool isReference = false;
		if (Multiple) 
		{
			result.Append("params ");
		}
		switch(Type)
        {
			case "tag":
			case "date":
			case "string":
			case "interval":
			case "aggFunc":
			case "aggOrSeriesFunc":
				result.Append("string");
				isReference = true;
				break;
			case "boolean":
				result.Append("bool");
				break;
			case "float":
				result.Append("double");
				break;
			case "integer":
			case "intOrInf":
				result.Append("int");
				break;
			case "node":
				result.Append("uint");
				break;
			case "seriesList":
			case "seriesLists":
				result.Append("SeriesListBase");
				isReference = true;
				break;
			case "any":
				result.Append("object");
				isReference = true;
				break;
			default:
				return "undefined";
		}
		if (Multiple) 
		{
			result.Append("[]");
			isReference = true;
		}
		if (!Required && !HasDefault && !isReference) result.Append('?');
		result.Append(' ').Append(Name);
		if (HasDefault)
		{
			result.Append(" = ");
			switch(Type)
			{
				case "tag":
				case "date":
				case "string":
				case "interval":
				case "aggFunc":
				case "aggOrSeriesFunc":
					result.Append('"').Append(Default).Append('"');
					break;
				case "boolean":
					result.Append(Default.ToLowerInvariant());
					break;
				case "integer":
				case "intOrInf":
					if (Default == "INF" || Default == "Infinity")
						result.Append("Int32.MaxValue");
					else
						result.Append(Default);
					break;
				case "float":
					if (Default == "INF")
						result.Append("Double.PositiveInfinity");
					else
						result.Append(Default);
					break;
				case "node":
					result.Append(Default);
					break;
				default:
					return "undefined";
			}
		}
		else if (!Required)
        {
			switch(Type)
            {
				case "seriesList":
				case "seriesLists":
				case "float":
				case "date":
				case "any":
					result.Append(" = null");
					break;
				case "string":
					if (!Multiple)
						result.Append(" = null");
					break;
			}
		}
		return result.ToString();
	}
	
	public string GetBody()
    {
		switch(Type)
        {
			case "boolean":
				return $"{Name}?1:0";
			case "date":
			case "tag":
			case "string":
			case "interval":
			case "aggFunc":
			case "aggOrSeriesFunc":
				if (Multiple)
					return $"{Name}.Select(SingleQuote).ToArray()";
				return $"SingleQuote({Name})";
			case "integer":
			case "intOrInf":
			case "node":
			case "seriesList":
			case "seriesLists":
			case "any":
				return Name;
			case "float":
				if (Required || HasDefault)
					return $"{Name}.ToString(\"r\", CultureInfo.InvariantCulture)";
				return $"{Name}?.ToString(\"r\", CultureInfo.InvariantCulture)";
			default:
				return "broken";
		}
    }
}
#>